<!DOCTYPE html>
<html lang="ru">
<head>
	<title>Вычисление констант на этапе компиляции — Блог Конфуция</title>
	<!--# include virtual="/inc/common-head.html" -->
</head>
<body>
<!--# include virtual="/inc/common-top.html" -->
<div class="main-wrapper">

<a href="/" class="blog-name">Блог Конфуция</a>

<div class="post">
	<section>
		<h class="title">Вычисление констант на этапе компиляции</h>
		<span class="date">02.02.2010</span>
		<section class="content">
		<p>Решили сортировать объекты по новизне. Если объект создан не позже чем полгода назад, то его считаем новым. «Полгода» решили хранить в количестве секунд: <code>3600 * 24 * (366 / 2) * 1000</code>. Из этого выражения сразу видно, что за полгода мы берем половину високосного года, не учитывая никаких високосных минут или секунд.</p>

<p>И вот, так как мы на скорости повернутые (а иначе Иншейкер бы и не завелся), решили узнать, что быстрее: вычислить самим и зашить в код число 15811200000, или же оставить вычисления на совести машины. Под «чем быстрее», конечно, не стоит понимать выигрыш нескольких наносекунд. Дело в принципе: умеют ли современные интерпретаторы яваскрипта сворачивать такие выражения еще на этапе компиляции. Мало ли когда пригодится ;)</p>

<p>Получился небольшой тестик (<a href="http://kung-fu-tzu.github.com/liby/tests/benchmarks/compile-time-arithmetics.html">полная версия</a>):</p>

<pre><code class="javascript">
console.time('1 + 1 + … + 1')
var sumA = 0
for (var i = 0; i < 100000; i++)
	sumA += 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +
			1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +
			// and ~100 lines more
			1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
console.timeEnd('1 + 1 + … + 1')
	
var sumB = 0
console.time('+ 2430')
for (var i = 0; i < 100000; i++)
	sumB += 2430
console.timeEnd('+ 2430')
</code></pre>

<p>А вот и результаты. Фаерфокс умеет это с незапамятных времен. То есть все доступные мне версии (1.5, 2.0, 3.0, 3.5, 3.6) выполнили оба цикла меньше чем за 10 миллисекунд. Хром (4.0) и Сафари (4.0) тоже свернули сумму, на сколько можно об этом судить по времени выполнения в одну миллисекунду. Оперы никакие (9.2, 9.5, 9.6, 10, 10.5) этого не умеют. Больше того 9.2 думала над первым циклом 10 секунд, 9.5, 9.6 и 10 по две секунды, а Опера 10.5 не смогла скомпилить (<a href="mailto:DSK-278503@bugs.opera.com">баг</a>) столь длинное выражение из сумм. Эксплореры ушли не дальше Опер: ни один из них (6, 7, 8) не смог угадать маневр, и все они потратили на первый цикл по три секунды. Второй цикл все версии всех браузеров прокрутили в пределах 10-20 миллисекунд.</p>

<p><strong>UPD 2010-02-02</strong>: Если в середину этой кучи суммирования вставить одну единственную переменную, то все браузеры сдаются и начинают честно считать сумму в рантайме. А Хром отказывается парсить тест, ссылаясь на переполнение стека вызовов («Maximum call stack size exceeded», <a href="http://code.google.com/p/v8/issues/detail?id=596">баг</a>).</p>

<p>Старый добрый перл умел такие оптимизации когда еще и браузеров-то не было ;)</p>
		</section>
	</section>
	
	<dl class="tags">
		<dt class="head">Теги:</dt>
		<dd class="body">
			<ul class="list"><li class="tag">javascript</li><li class="tag">performance</li></ul>
		</dd>
	</dl>
	
	<div class="comments">Очень жду ваших комментариев <a href="mailto:Комментарии блога Конфуция <comments@kung-fu-tzu.ru>?subject=Re: Вычисление констант на этапе компиляции">на почту</a>.</div>
</div>

</div>
<!--# include virtual="/inc/common-bottom.html" -->
</body>
</html>