<!DOCTYPE html>
<html lang="ru">
<head>
	<title>git filter-branch — Блог Конфуция</title>
	<!--# include virtual="/inc/common-head.html" -->
</head>
<body>
<!--# include virtual="/inc/common-top.html" -->
<div class="main-wrapper">

<a href="/" class="blog-name">Блог Конфуция</a>

<div class="post">
	<section>
		<h class="title">git filter-branch</h>
		<span class="date">11.07.2009</span>
		<section class="content">
		<p><em>Завтра переписывал историю. Понравилось.</em></p>

<p>Напишу тут немного про <a href="http://www.kernel.org/pub/software/scm/git/docs/git-filter-branch.html">git filter-branch</a> потому, что ничего внятного ни на русском, ни на аглицком нагуглить не удалось. Повторять мои ошибки вам будет дороговато, так как более менее сложное отфильтровывание истории — штука скучная и затяжная.</p>

<p>Не забудьте забекапить папочку <code>.git</code> из вашего репозитория.</p>


<h3>Раздвоение</h3>

<p>Если у вас больше одного бранча (а как же иначе?), то, судя по названию команды, отфильтровать получится историю только текущего бранча. И вы получите раздвоение репозитория. А это значит, что лучше всего сначала смерджить все в мастер, и только потом начинать творить все эти противоестественные вещи. Даже больше. Если вы работате в команде (а как же иначе?), то важно всем все смерджить в свои мастеры, а потом смерджить все мастеры у кого-то одного, и только потом запускать <code>git filter-branch</code> на его компе. Иначе, получив новый репозиторий с абсолютно иными именами коммитов, вы замучаетесь мерджиться друг с другом. Еще хуже то, что новая история будет только у того, кто ее себе смастерил. Остальные перцы (включая боевые сервера, если вы храните на них репу целиком) получат из новой истории только последний комит, а впридачу всю его новую историю в качестве багажа.

Повторим. Сначала слейте все в один репозиторий, потом максимально упростите его структуру, а потом уже издевайтесь над ним. В случае, если не удается смердить все в мастер, запустите фильтр сначала в мастере, а потом в каждом из оставшихся бранчей. Чтобы не тратить время на переписывание тех коммитов, которые общие у мастера и у текущей ветки, воспользуйтесь опциями для выделения отрезка истории, описанными в руководстве. Мужайтесь.

После того, как вы перелопатили историю на одном из компьютеров, знайте, что это практически новый репозиторий. А это значит, что его надо всем заново склонировать (не забудьте про боевые и сборочные сервера). Чтобы быстрее заливалось, запустите <code>git gc --aggressive</code>, и гит аккуратненько уложит все объекты в один файл.</p>

<h3>Редактируем авторов</h3>

<p>Так как мы в <a href="http://www.inshaker.ru/">Иншейкере</a> на гит набросились, как голодные псы, никто, конечно, не удосужился сконфигурировать свои имя и мыло через <code><a href="http://github.com/guides/tell-git-your-user-name-and-email-address">git configure --global</a></code>.</p>

<p>Чтобы исправить эту досадную ошибку и заменить логин в системе на свое имя, а кривой адрес — на прямой, запускайте:
<pre><code class="bash">git filter-branch --env-filter \
'
if [ "$GIT_AUTHOR_NAME" = "user123" ];
then
  export GIT_AUTHOR_NAME="User Name"
fi

if [ "$GIT_AUTHOR_EMAIL" = "user123@host.local" ];
then
  export GIT_AUTHOR_EMAIL="user@name.ru"
fi
'
</code></pre></p>

<h3>Выбрасываем мусор</h3>

<p>Как-то давно, мы решили хранить псдшники и видео в репозитории. Наверное заболели. Вот лекарство от файлов <code>*.flv</code>, <code>*.mp3</code> и <code>*.psd</code> (нужное подчеркнуть):
<pre><code class="bash">git filter-branch --tree-filter 'find . \( -name "*.flv" -o -name "*.mp3" -o -name "*.psd" \) -exec rm -rf {} \;'</code></pre></p>


<h3>Если не получается</h3>

<p>Повторно запускать фильтр гит откажется, предупреждая о том, что придется затереть бекап. Вылетит со словами «Cannot create a new backup. A previous backup already exists in refs/original/». Настоять на своем можно, указав ключ <code>-f</code> или вручную стерев папочку <code>refs/original/</code>. Кстати, да, всего несколько файликов в этой папочке и есть весь «бекап». Дело в том, что гит очень умный, и он не удалит старое пространство объектов, пока вы его явно об этом не попросите (<code>git gc --prune=now</code>). Именно поэтому, пока в папке <code>refs/</code> есть ссылки на старое дерево, ничего не удалится. В общем, стандартный сборщик мусора, знакомый нам по яваскрипту.</p>

<p>Если вы переписывали историю для того, чтобы выбросить из нее мусор, а по окончании мучений репа стала даже чуть больше, не отчаивайтесь. Дело как раз в бекапе. Чтобы стопроцентно очистить репозиторий, надо склонировать этот репозиторий в другое место и запустить там <code>git gc --prune=now</code>. Не очень красиво, но так <a href="http://www.kernel.org/pub/software/scm/git/docs/git-filter-branch.html#_checklist_for_shrinking_a_repository">официально советуют</a> делать.</p>

<p>Знаю по опыту, что гит ошарашивает своей гибкостью и многословием. Поэтому — спрашивайте, если что-то не получается. Было бы мне у кого спросить, замучал бы его совсем :)</p>
		</section>
	</section>
	
	<dl class="tags">
		<dt class="head">Теги:</dt>
		<dd class="body">
			<ul class="list"><li class="tag">сервер</li><li class="tag">git</li></ul>
		</dd>
	</dl>
	
	<div class="comments">Очень жду ваших комментариев <a href="mailto:Комментарии блога Конфуция <comments@kung-fu-tzu.ru>?subject=Re: git filter-branch">на почту</a>.</div>
</div>

</div>
<!--# include virtual="/inc/common-bottom.html" -->
</body>
</html>