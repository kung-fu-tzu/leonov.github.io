<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
<channel>
<title>Блог Конфуция</title>
<link>http://kung-fu-tzu.ru/</link>
<lastBuildDate>Mon, 29 Nov 2010 00:21:08 +0000</lastBuildDate>
<generator>just a ruby script</generator>
<language>ru</language>

<item>
<title>Произвольный линукс в контейнере</title>
<link>http://kung-fu-tzu.ru/posts/2010/11/28/changing-os-in-virtuozzo/</link>
<pubDate>Sun, 28 Nov 2010 22:58:01 +0000</pubDate>
<category><![CDATA[сервер]]></category><category><![CDATA[ubuntu]]></category><category><![CDATA[virtuozzo]]></category><category><![CDATA[openvz]]></category><category><![CDATA[masterhost]]></category>
<guid isPermalink="false">http://kung-fu-tzu.ru/posts/2010/11/28/changing-os-in-virtuozzo/</guid>
<description><![CDATA[Саморучно меняем дистрибутив внутри OpenVZ-контейнера.]]></description>
<content:encoded><![CDATA[<p>Началось все с того, что техподдержка мастерхоста отказала в установке операционки на наш выбор. А разрешается на их виртуальные серверы ставить только дебиан 5, федору 7 и центос 5. Пятый дебиан полностью устроил бы, если бы в нем уже был <a href="http://upstart.ubuntu.com/">апстарт</a>, а будет апстарт только в шестой версии. И без него никак. А так как операционки на наших старых серверах уже давно устарели (Ubuntu 6.10 последовательно обновленная до 8.04), пришла пора все менять.</p>

<p>У нас в офисе уже полтора года вертится <a href="http://kung-fu-tzu.ru/posts/2009/04/28/mac-os-leopard-launchd-vboxheadless/">несколько OpenVZ-контейнеров</a>. Для домашних нужд все подходит просто прекрасно. Вдобавок, из экспериментов с OpenVZ удалось вынести несколько полезных наблюдений. Вот они, кстати. Чистый виртуозный контейнер — это всего-лишь небольшая папочка да один конфиг. Готовых контейнеров с разными дистрибутивами линукса <a href="http://wiki.openvz.org/Download/template/precreated">пруд пруди</a>. Всей виртуализации в OpenVZ, по большому счету: изоляция файловой системы, разделение памяти и процессора, да айпишников. Ядро одно на всех, тип файловой системы — один, и никакой магии с виртуализацией устройств. А еще свою виртуалку внутри контейнера не запустишь (если только полноценный эмулятор запустить). Итого, с одной стороны — никакой тонкой настройки под железо, а с другой — никакого геморроя с этим железом. Вдобавок, возможен интересный трюк, о котором эта статья.</p>

<p>Итак. Ось можно элементарно заменить, удалив все файлы старой системы и заменив файлами из новой. Конечно, в процессе надо не уронить уже запущенную систему и суметь потом попасть в новую. Иначе получим кирпич вместо сервера. И, да, прочитайте, пожалуйста, весь пост до конца, чтобы понять, сумеете ли вы потом получить доступ к новой системе, или, хотя бы, восстановить старую.</p>

<h3>Подготовительный этап</h3>

<ul>
	<li>делаем полный бекап контейнера (лучше создайте новый и мучайте его);</li>
	<li>заходим под рутом по SSH;</li>
	<li>создаем папочку <code>new-system</code> там, где вам удобно;</li>
	<li>скачиваем в <code>new-system</code> образ новой оси (у меня это <code>ubuntu-10.04-x86.tar.gz</code>);</li>
	<li>заходим в <code>new-system</code> и распаковываем образ (<code>tar xzf ubuntu-10.04-x86.tar.gz</code>).</li>
</ul>

<p>В итоге, папочка <code>new-system</code> (у меня <code>/root/new-system</code>) содержит структуру каталогов новенькой операционки. На следующем шаге мы заменим текущую операционку новой. Только, вот один важный момент. В данном примере новая система родственна старой (сестрички Ubuntu 10.04 и Debian 5.0), поэтому надо будет заменить всего несколько папок, оставив остальные нетронутыми. Если вы собираетесь менять федору на генту, будьте готовы немного поэкспериментировать.</p>

<h3>Заеняем системные файлы</h3>

<p>Для того, чтобы сократить период перехода системы из одного состояния в другое, не стоит сразу удалять папки старой системы. Достаточно переименовать их, а на их место переместить новые. Так как мы заменяем все привычные программы, типа <code>mv</code>, <code>rm</code>, <code>mkdir</code>, придется делать все вручную прямо из sftp-клиента.</p>

<ul>
	<li>переименовываем эти папки новой системы: <code>bin</code>, <code>dev</code>, <code>etc</code>, <code>lib</code>, <code>sbin</code>, <code>usr</code>, <code>var</code>, во что-то типа <code>bin1</code>, <code>dev1</code>, <code>etc1</code> и т.д.;</li>
	<li>перемещаем переименованные папки из <code>new-system</code> в корень, они встанут бок о бок с папками текущей оси;</li>
	<li>одну за другой переименовываем получившиеся пары по такому шаблону <code>bin</code> ⟶ <code>bin0</code>, <code>bin1</code> ⟶ <code>bin</code>.</li>
</ul>

<p>Перезагружаемся. Запустится новая система. Так как мы развернули кем-то заранее подготовленный образ, в нем уже будет запущен <code>sshd</code>. Только вот пароль рута будет другой. Если вы обновляли контейнер на хостинге с контрольной панелью (которая, на 4643-м порту), то можете смело менять его оттуда. Можно схитрить и сохранить файл <code>/root/.ssh/authorized_keys</code> от старой системы. Тогда нас пустят по ключу, и можно будет спокойно менять пароль рута через <code>passwd</code>. Теперь оставшиеся от старой системы папки можно спокойно удалять (или архивировать на память).</p>


<p>П.С. У нас контейнеры такие: <code>Linux vXXXX.vps.masterhost.ru 2.6.18-028stab070.7 #1 SMP Fri Oct 1 13:53:00 MSD 2010 i686 GNU/Linux</code>.</p>]]></content:encoded>
</item><item>
<title>Про заголовки в энжи</title>
<link>http://kung-fu-tzu.ru/posts/2010/05/14/post-about-nginx-headers/</link>
<pubDate>Fri, 14 May 2010 19:14:35 +0000</pubDate>
<category><![CDATA[srver]]></category><category><![CDATA[nginx]]></category>
<guid isPermalink="false">http://kung-fu-tzu.ru/posts/2010/05/14/post-about-nginx-headers/</guid>
<description><![CDATA[Пытаюсь писать не на русском про сложные вещи.]]></description>
<content:encoded><![CDATA[<p>Пока писал управление заголовками из яваскриптового модуля, удалось родить немного текста <a href="http://kung-fu-tzu.ru/pages/nginx/headers-management/">на английском про заголовки в энжинксе</a>. А не на русском <a href="http://softwaremaniacs.org/blog/2010/04/01/switching-locale/">вот почему</a>.</p>]]></content:encoded>
</item><item>
<title>Еще чуть-чуть о MVC</title>
<link>http://kung-fu-tzu.ru/posts/2010/04/08/about-mvc/</link>
<pubDate>Thu, 08 Apr 2010 14:55:45 +0000</pubDate>
<category><![CDATA[клиент]]></category><category><![CDATA[javascript]]></category><category><![CDATA[mvc]]></category><category><![CDATA[inshaker]]></category>
<guid isPermalink="false">http://kung-fu-tzu.ru/posts/2010/04/08/about-mvc/</guid>
<description><![CDATA[Про то, как мы готовим MVC.]]></description>
<content:encoded><![CDATA[<p><strong>UPD 2010-11-28</strong>: Статейка получилась такая, какая получилась ;) Из текста можно понять, что автор еще не полностью въехал в суть проблемы. Скоро напишу хорошую, годную статью по следам новейших исследований британских ученых.</p>

<p>Модель, она данными занимается. Контроллер нужен чтобы связывать модель и представление, это чтобы модель могла ничего не знать про представление. Ну, а представление просто все рисует по данным из модели. Казалось бы, куда уж проще? Да, просто, но как только начинаешь делать что-то реальное возникает куча вопросов.</p>

<section>
<h>Куча вопросов</h>

<p>Разделять код? Зачем?</p>
<p>Зачем нужен этот «цикл МВЦ»?</p>
<p>С чего все начинается?</p>
<p>Что значит одно «вызывает» другое?</p>
<p>Можно ли как-то нарушать правила движения?</p>
<p>А как же производительность?</p>
</section>


<section>
<h>Разделяй и властвуй</h>

<p>Зачем делить? Судя по опыту, только для упрощения программирования. Не себе, конечно, а тому парню, который потом будет разбираться в вашем коде. Тут собственно все вокруг этого и строится. MVC это ж ведь паттерн. Правда, такая схема будет работать только в том случае, если «тот парень» тоже сдвинут на этом паттерне и знает, какой стороной его держать.</p>

<p>Судя по своим ощущениям, это реально упрощает программирование мне, когда выдается возможность что-то поковырять в новом для меня коде. Если мне известно, что там «правильный» MVC — что бы это ни значило для меня — то работа всегда пойдет быстро. Мне известно, что ноды генерятся во вьюхе. Там же на них вешаются всякие онклики. Сразу пропускаю контроллер, так как он всегда все передает в модель, меняя только название метода. Дальше, в модели мне тоже все понятно: тут, типа, данные в чистом виде, безо всякого мусора. Тут я как раз ковыряю какую-нить логику сортировки чего-нить и передаю данные дальше. Удобно.</p>

<p>Разделение вообще полезно, особенно в больших проектах. Круто, когда разработчик модели должен всего-то договориться о нескольких методах с разработчиком представления, теперь он может полностью отдаться оптимизации аяксовых запросов, кешированию и другим потрясающим вещам. Второй чувак, который паяет вьюху, может, в свою очередь, забыть про сервер вообще и думать только о том, как наиболее эффективно сгенерить стопицот нод с картинками, как организовать отложенную загрузку чего-нибудь и, наконец, исправить ту разъехавшуюся страничку в шестом ИЕ.</p>

<p>Попытаюсь проиллюстрировать примером:</p>
<pre><code class="javascript">
// вывод щенков вне зависимости от того, откуда их привезли
Widget.View.prototype.renderTheCutePuppiesNames = function (puppies)
{
	// вьюха уже хорошо знает, куда надо нарисовать щенков
	// а именно в какой-то ранее созданный элемент ul или ol
	var puppiesRootNode = this.puppiesRootNode
	
	for (var i = 0; i < puppies.length; i++)
	{
		// создаем для щенка элемент списка
		var li = document.createElement('li')
		// говорим стилям, что это именно симпатичный щенок
		li.className = 'cute-puppy'
		// добавляем щенку текст с именем в лучших традициях DOM API
		li.appendChild(document.createTextNode(puppies[i].name))
		// добавляем вновь созданный елемент с имем щенка в список
		puppiesRootNode.appendChild(li)
	}
}

// просто добавляем щенка в массив и не думаем о том, где их будут показывать
Widget.Model.prototype.addACutePuppy = function (puppy)
{
	// добавдяем симпатичного щенка в модель
	this.data.push(puppy)
	
	// оповещаем вьюху о том, что щенков поприбавилось
	this.view.modelChanged(this.data)
}

// не запариваясь передадим модели нового щенка
Widget.Controller.prototype.newCutePuppyAdded = function (puppyName)
{
	// не просто передадим, а обернем в объект, чтобы модели было удобнее,
	// контроллер же как раз для этого и нужен ;)
	this.model.addACutePuppy({name: puppyName})
}
</code></pre>
</section>


<section>
<h>В цикле</h>

<p>Под циклом все понимают последовательность передачи управления: View -> Controller -> Model -> View. Это все видели на картинках про MVC. А зачем он нужен? И почему именно в такой последовательности?</p>

<p>Здесь дело опять же в предсказуемости действий. Кликнули мышкой и знаем, что это событие обработает представление: выяснит, над какой нодой мы кликнули мышкой, связан ли с этой нодой объект, если да, то пора передать его, и только его в контроллер. Контроллер быстренько превращает осмысленное действие «кликнут коктейльный ингредиент такой-то» в робоподобное «переключить цвет шерсти щенка такого-то в зеленый». Когда дело доходит до модели, мы уже точно знаем, что надо делать, все лишние детали возникшего события остались на предыдущих этапах обработки, а значит, можно просто применить новые данные к модели и, если она изменилась, оповестить об этом представление.</p>

<p>Еще один бонус в том, что заранее известны все точки входа в код. Это всегда методы вьюхи, которые реагируют на события, пришедшие от пользователя. Возможность перечислить точки входа очень полезна при изучении кода, который написан давно и/или кем-то другим.</p>

<p>Маленький пример:</p>
<pre><code class="javascript">
// мы можем подписаться на все интересующие виджет события прямо тут,
// ах, как же потом будет удобно все это сопровождать :)
Widget.View.prototype.bindEvents = function (nodes)
{
	// для замыкания
	var input = nodes.input,
		me = this
	// подписываемся на клик и все, остальное — дело контролёра ;)
	nodes.button.addEventListener('click', function (e) { me.controller.newCutePuppyAdded(input.value) }, false)
}
</code></pre>
</section>


<section>
<h>Первый круг</h>

<p>Когда виджет только-только создан, он еще пустой. Движок MVC сначала надо прогреть. Прогреваем мы вот как. В представлении запоминаем ноды, которые надо будет наполнить новыми элементами, подписываемся на события, инициализируем сторонние виджеты. В модели сохраняем объекты-обертки для базы данных, предвычисляем всякие индексы, что-нибудь кешируем. После прогрева MVC полностью готов к бою. Пора взлетать, то есть запускать тот самый первый круг цикла. Обычно, представление как-то вычисляет, что конкретно надо рисовать по данным, переданным на этапе прогрева. Надо только передать контроллеру эти данные. Сейчас буду показывать пример, чтобы все стало ясно.</p>

<pre><code class="javascript">
Widget.prototype.bind = function (nodes, dataSources)
{
	// тут просим представление запомнить свои корневые ноды,
	// подписаться на события мыши или клавы,
	// насоздавать других вложенных виджетов и так далее
	this.view.setNodes(nodes)
	
	// тут просим модель запомнить источники данных,
	// с которыми ей предстоит работать
	this.model.setSources(dataSources)
}

Widget.prototype.setPuppies = function (puppies)
{
	// просим контроллер передать модели те данные,
	// которые станут ее первоначальным состоянием
	this.controller.setInitialPuppies(puppies)
}

// создаем пустой виджет, он еще не прогрет
var widget = new Widget()

// прогреваем виджет
widget.bind(nodes, dataSources)

// взлетаем
widget.setPuppies(['Тузик', 'Бобик', 'Шарик', 'Мухтар'])

// теперь виджет готов адекватно реагировать на внешние события
widget.getPuppy('Мурзик')
//=> Exception: "Мурзик" is an incorrect name for a puppy
</code></pre>
</section>


<section>
<h>Это вызов</h>

<p>У кого как, а у нас передача сообщений между частями MVC, это простые вызовы методов. То есть мы не создавали вокруг MVC никаких дополнительных построек, типа <a href="https://developer.mozilla.org/en/DOM/EventTarget">EventTarget</a> или <a href="http://en.wikipedia.org/wiki/Observer_pattern">Observer</a>. То есть виджет у нас всегда состоит из одной модели, одного представления и одного контроллера. Между ними все и вертится. Если нужно, например, два представления, то это легко организовать с помощью чего-то типа паттернов, перечисленных выше. Надо искренне стараться не усложнять простое и упрощать сложное ;)</p>

<p>Один важный момент, это асинхронность. Если модель должна обратиться за данными на сервер, то тут возникает вопрос: как же быть с простыми вызовами методов? Все просто. Модель должна сама с этим справиться, внутри себя. То есть, получив сообщение от контроллера, модель лезет на сервер, что-то там запрашивает, ждет, получает все необходимые данные и только затем дергает представление с новыми данными. Просто вызывает метод, как если бы не было всей этой возни с сервером. Пока модель выполняет все эти действия, вьюха отдыхает как ни в чем не бывало.</p>

<p>Забавно то, что методы, которые вызываются для передачи сообщения не могут вернуть никакого значения. Ну, то есть могут, но это лишено смысла, так как результат вызова придет с другой стороны: как раз по этому самому кругу MVC. Эта хитрость избавляет от необходимости синхронного выполнения всех задач в любой части MVC. Непривычно, но скоро становится очень удобно.</p>

<p>Небольшая иллюстрация важного асинхронного момента:</p>
<pre><code class="javascript">
// добавляем щенка, предарительно проверив допустимость его клички
Widget.Model.prototype.addAStrangePuppy = function (puppy)
{
	function checked (e)
	{
		if (e.result == 'error')
			// если имя в базе не найдено — громко ругаемся
			throw new Error('"' + puppyName + '" is an incorrect name for a puppy')
		else
		{
			// спокойно добавляем нового щенка,
			// эта функция в свою очередь дернет вьюху с новым набором щенков
			this.addACutePuppy(puppy)
		}
	}
	
	// спрашиваем сервер, правильное ли имя у нового щенка?
	// вторым параметром передадим колбек: представим, что обертка базы работает именно так ;)
	this.dataSources.puppyDataBase.checkPuppyName(puppy.name, checked)
}
</code></pre>
</section>


<section>
<h>Против шерсти</h>

<p>В принципе, никто не мешает представлению лезть в модель за данными самостоятельно. Контроллер может иногда забить на модель и вызвать представление самостоятельно. Модель тоже может потянуться к представлению за какой-то информацией о состоянии. И так далее. Если у вас такое происходит, то об этом надо предупреждать, так как этого от вас никто не ждет ;) В нарушении правил движения есть пара особенно неприятных моментов.</p>

<p>Первый момент. Действительно встречаются такие события в представлении, которые никак не влияют на модель. Но если они не влияют на модель, зачем тогда они нужны? Ведь весь смысл представления в этом самом представлении модели. То есть всегда полезно думать о представлении и контроллере как о помощниках модели. Они помогают отобразить то, что у модели на душе. То есть весь интерфейс с выведенными данными должен быть воспроизводим только по данным модели. Это значит, что можно взять состояние модели, сдампить его в JSON, перезагрузить страничку, скормить модели этот JSON и получить точь-в-точь такой же виджет, каким он был до перезагрузки.</p>

<p>Второй момент, это асинхронность. Как мы помним, модель может захотеть сходить в сеть за новой порцией данных. Потом она может их как-то обработать, закешировать или отбросить. Если мы полезем напрямую в модель из представления, никто нам не гарантирует, что мы не напоремся на пустые, еще не пришедшие данные, или не ввергнем страничку в бесконечный цикл запросов к серверу. Для борьбы с такими неприятностями можно вовсю пользоваться приватными методами. Это как раз тот способ, которым можно просто запретить движение в неудобном модели направлении.</p>

<p>Знаю только один случай когда вся эта изолированно-асинхронная модель рушится. Это тогда, когда кто-то нажал на кнопку отправки формы и надо либо блокировать отправку, либо разрешить. А данные, необходимые для принятия решения, лежат в модели. Вызвать модель мы можем, но получим от нее результат неизвестно когда. В таком случае, можно либо сразу заблокировать отправку формы, отправить сообщение в модель про то, что надо бы отправить эту форму. Модель там покумекает, и, возможно, разрешит-таки форму отправить. При таком раскладе, представление может принудительно отправить форму методом <code>form.submit()</code>. А что делать, если это не форма, а, например, событие драгэндропа, пришедшее от операционки через браузер. Операционка не будет ждать выполнения нашего аякса. В таких ситуациях MVC уже мешает и его придется нарушать.</p>
</section>


<section>
<h>Производительность</h>

<p></p>

</section>

]]></content:encoded>
</item><item>
<title>Хитрые строки против склеивания массива</title>
<link>http://kung-fu-tzu.ru/posts/2010/02/05/cons-strings-vs-array-join/</link>
<pubDate>Fri, 05 Feb 2010 10:37:59 +0000</pubDate>
<category><![CDATA[клиент]]></category><category><![CDATA[javascript]]></category><category><![CDATA[performance]]></category><category><![CDATA[string]]></category><category><![CDATA[v8]]></category>
<guid isPermalink="false">http://kung-fu-tzu.ru/posts/2010/02/05/cons-strings-vs-array-join/</guid>
<description><![CDATA[Сравниваем скорость новой конкатенации строк и старого склеивания массива строк. ]]></description>
<content:encoded><![CDATA[<p>Почитывая рассылку <a href="http://groups.google.com/group/v8-users">v8-users</a>, заметил интересную тему про оптимизации, специфичные для v8. Особенно интересным показалось сообщение <a href="http://groups.google.com/group/v8-users/browse_thread/thread/fa6746b6fa2d4b2c#msg_13f5f3e44a1c3740">о ConsStrings</a> (<a href="http://lingvo.yandex.ru/en?text=cons&lang=en&search_type=lingvo&st_translate=on">cons в словаре</a>). И вот, собственно, об этих «составных строках» мне и хочется рассказать. Так как восторг! :)</p>

<section>
<h>Загадка</h>

<p>Веб текстовый как со стороны клиента, так и со стороны сервера (особенно сервера). И всем нам постоянно приходится клеить кучу мелких строк в большие строки, а эти большие — в еще б<em>о</em>льшие, и так далее. На сервере путь последней, самой большой строки (отрендеренной странички, например), оканчивается на передаче их ядру операционки для отправки по сети. В браузере, обычно, строки финишируют на присваивании <code>node.innerHTML = string</code> или так же, как на сервере — перед отправкой в сокет (аяксом, например).</p>

<p>Самая вкуснятина в том, что большинство промежуточных строк никому не нужно. Они часто даже своих переменных не имеют и являются всего лишь временными контейнерами для строк большего размера. В худшем случае на каждую конкатенацию требуется: сначала выделить память для новой строки, проинициализировать ее, защитить от сборки мусора, скопировать в выделенную память две (!) склеиваемые строки, передать полученную строку дальше, а потом уничтожить. Но всего этого можно избежать, если…</p>
</section>

<section>
<h>Разгадка</h>

<p>… если строки в вашем любимом языке нельзя изменять, то есть при любом воздействии всегда создается новая строка, а исходная строка остается нетронутой. Тогда пропадает необходимость сразу копировать конкатенируемые строки в новую область памяти, достаточно только запомнить, из каких строк состоит новая склеенная строка, а реальное копирование отложить до лучших времен. Может показаться, что все эти манипуляции только усложнят и замедлят работу со строками, но нет, все наоборот (особенно в скриптовом языке), и мы это проверим в небольшом тесте.</p>

<p>Судя по сообщению в рассылке, в v8 конкатенация строк построена как раз по такому принципу (в перле, помнится, это тоже уже давно есть). Цитирую это сообщение <a href="http://twitter.com/erikcorry">Эрика Кори</a>: «Когда вы используете <code>+=</code>, V8 создает структуру типа <code>ConsString</code>, это узел дерева, который занимает 20 байт на 32-х разрядных машинах или 32 байта — на 64-х разрядных. Это относительно быстрая операция. Как только вы пытаетесь использовать строку для чего-то отличного от конкатенации, она превращается в простую «плоскую» строку похожим способом, как бы это сделал <code>join</code> (имеется ввиду <code>Array#join()</code>). Узел <code>ConsString</code> становится мусором, который мы можем собрать довольно быстро. Алгоритм, по которому должен работать <code>join</code>, описан в крайне загадочных спецификациях (например, работа с разреженными массивами), потому <code>join</code> — это не совсем простая операция…».</p>

<p>И последнее, что мне бы хотелось узнать (сейчас уже не осилю, но как узнаю — допишу), умеет ли кто-нибудь так же хитрить со сравнением строк. Ведь, при такой отложенной склейке строк, можно заодно складывать контрольные суммы этих строк. А когда понадобится сравнить две составные строки строки, то можно будет сначала сравнить их контрольные суммы, и только если суммы совпадают, собрать обе строки и честно сравнить.</p>
</section>

<section>
<h>Тестим</h>

<p>Сравнить производительность простой конкатенации (от которой мы всегда старались уйти) и склеивания массива очень просто. Единственный важный момент, чтобы честно сравнить время, надо попросить движок яваскрипта «собрать» полученную строку (например, пробежавшись регуляркой), если она у него хранится как дерево. Вот небольшой тестик (<a href="http://kung-fu-tzu.github.com/liby/tests/benchmarks/cons-string-vs-array-join.html">полная версия</a>):</p>

<pre><code class="javascript">
// испечем массив исходных строк
// обязательно разных и обязательно честных,
// иначе будем мерить неизвестно что
function bake (arr, prefix, count)
{
	console.time('bake')
	var rex = /xxx/
	for (var i = 0; i < count; i++)
		arr[i] = prefix + i,
		rex.test(arr[i]) // «собираем» строку
	console.timeEnd('bake')
}

var count = 100000, // сколько строк
	rex = /^\w/ // тестовый рекс

;(function(){
	var src = [], prefix = 'testA'
	bake(src, prefix, count)
	
	// берем самый неприятный случай,
	// когда мы не знаем сколько будет строк
	var joiner = []
	
	console.time('join()')
	for (var i = 0; i < count; i++)
		// а еще мы не можем использовать конструкцию joiner[i] = …
		// так как в реальной задаче у нас может не быть цикла
		joiner.push(src[i])
	
	var res = joiner.join('')
	var test = rex.test(res)
	console.timeEnd('join()')
	
	console.log(test, 'regexp test')
	console.log(res === src.join(''), 'index of prefix')
})();

;(function(){
	var src = [], prefix = 'testB'
	bake(src, prefix, count)
	
	var joiner = ''
	
	console.time('+=')
	for (var i = 0; i < count; i++)
		joiner += src[i]
	
	var res = joiner // дублируем, чтобы быть честными
	var test = rex.test(res)
	console.timeEnd('+=')
	
	console.log(test, 'regexp test')
	console.log(res === src.join(''), 'index of prefix')
})();
</code></pre>

<p>Тестю все на том же стареньком интеловском маке.</p>

<p>Результаты вполне ожидаемые. В Хроме простая конкатенация строк в два раза быстрее, чем склеивание массива строк. В Сафари строго наоборот: массив в два раза быстрее строк. Фаерфокс показывает противоречивые результаты: в 3.0 и 3.5 строки процентов на 15% быстрее, чем склейка массива, а в 3.6 наоборот — строки немного отстают. Пока сошлюсь на погрешность измерений. В Опере картинка поинтереснее, все оперы складывают строки до нескольких раз раз быстрее, чем склеивают массив (зачет!). В эксплорере тоже не все печально: шестой делает <code>join()</code> в 50 раз быстрее конкатенации, седьмой — так же и за то же время, а вот восьмой складывает строки примерно в два раза быстрее, чем склеивает массив, да еще делает любое из этих действий в 100 раз быстрее чем шестой или седьмой на том же железе.</p>
</section>

<section>
<h>Итог</h>
Если делаете сайт, который собирается проработать годы, то забудьте о создании массива только для конкатенации строк. Если же старые эксплореры будут постоянными гостями, то, увы, пока придется клеить строки через массив.
</section>]]></content:encoded>
</item><item>
<title>Вычисление констант на этапе компиляции</title>
<link>http://kung-fu-tzu.ru/posts/2010/02/02/compile-time-arithmetics/</link>
<pubDate>Tue, 02 Feb 2010 16:09:26 +0000</pubDate>
<category><![CDATA[javascript]]></category><category><![CDATA[performance]]></category>
<guid isPermalink="false">http://kung-fu-tzu.ru/posts/2010/02/02/compile-time-arithmetics/</guid>
<description><![CDATA[Маленький тестик на наличие зачатков оптимизирующего компилятора.]]></description>
<content:encoded><![CDATA[<p>Решили сортировать объекты по новизне. Если объект создан не позже чем полгода назад, то его считаем новым. «Полгода» решили хранить в количестве секунд: <code>3600 * 24 * (366 / 2) * 1000</code>. Из этого выражения сразу видно, что за полгода мы берем половину високосного года, не учитывая никаких високосных минут или секунд.</p>

<p>И вот, так как мы на скорости повернутые (а иначе Иншейкер бы и не завелся), решили узнать, что быстрее: вычислить самим и зашить в код число 15811200000, или же оставить вычисления на совести машины. Под «чем быстрее», конечно, не стоит понимать выигрыш нескольких наносекунд. Дело в принципе: умеют ли современные интерпретаторы яваскрипта сворачивать такие выражения еще на этапе компиляции. Мало ли когда пригодится ;)</p>

<p>Получился небольшой тестик (<a href="http://kung-fu-tzu.github.com/liby/tests/benchmarks/compile-time-arithmetics.html">полная версия</a>):</p>

<pre><code class="javascript">
console.time('1 + 1 + … + 1')
var sumA = 0
for (var i = 0; i < 100000; i++)
	sumA += 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +
			1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +
			// and ~100 lines more
			1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
console.timeEnd('1 + 1 + … + 1')
	
var sumB = 0
console.time('+ 2430')
for (var i = 0; i < 100000; i++)
	sumB += 2430
console.timeEnd('+ 2430')
</code></pre>

<p>А вот и результаты. Фаерфокс умеет это с незапамятных времен. То есть все доступные мне версии (1.5, 2.0, 3.0, 3.5, 3.6) выполнили оба цикла меньше чем за 10 миллисекунд. Хром (4.0) и Сафари (4.0) тоже свернули сумму, на сколько можно об этом судить по времени выполнения в одну миллисекунду. Оперы никакие (9.2, 9.5, 9.6, 10, 10.5) этого не умеют. Больше того 9.2 думала над первым циклом 10 секунд, 9.5, 9.6 и 10 по две секунды, а Опера 10.5 не смогла скомпилить (<a href="http://kung-fu-tzu.ru/posts/2010/02/02/compile-time-arithmetics/mailto:DSK-278503@bugs.opera.com">баг</a>) столь длинное выражение из сумм. Эксплореры ушли не дальше Опер: ни один из них (6, 7, 8) не смог угадать маневр, и все они потратили на первый цикл по три секунды. Второй цикл все версии всех браузеров прокрутили в пределах 10-20 миллисекунд.</p>

<p><strong>UPD 2010-02-02</strong>: Если в середину этой кучи суммирования вставить одну единственную переменную, то все браузеры сдаются и начинают честно считать сумму в рантайме. А Хром отказывается парсить тест, ссылаясь на переполнение стека вызовов («Maximum call stack size exceeded», <a href="http://code.google.com/p/v8/issues/detail?id=596">баг</a>).</p>

<p>Старый добрый перл умел такие оптимизации когда еще и браузеров-то не было ;)</p>]]></content:encoded>
</item><item>
<title>Ветвисто</title>
<link>http://kung-fu-tzu.ru/posts/2010/02/02/lots-of-branches/</link>
<pubDate>Tue, 02 Feb 2010 14:41:02 +0000</pubDate>
<category><![CDATA[git]]></category><category><![CDATA[inshaker]]></category>
<guid isPermalink="false">http://kung-fu-tzu.ru/posts/2010/02/02/lots-of-branches/</guid>
<description><![CDATA[Иншейкер заметно разветвился.]]></description>
<content:encoded><![CDATA[<p>Еще один пост во славу <a href="http://git-scm.com/">гита</a>! Вот такая картина веток образовалась сегодня. Как бы мы жили с ЭссВэЭном? А как оно все пулью работает.</p>
<p><img src="http://kung-fu-tzu.ru/posts/2010/02/02/lots-of-branches/i/lots-of-branches.png" style="border:4px solid #eee"/></p>]]></content:encoded>
</item><item>
<title>Пуст ли объект?</title>
<link>http://kung-fu-tzu.ru/posts/2010/01/29/is-an-object-empty/</link>
<pubDate>Fri, 29 Jan 2010 11:43:12 +0000</pubDate>
<category><![CDATA[клиент]]></category><category><![CDATA[javascript]]></category>
<guid isPermalink="false">http://kung-fu-tzu.ru/posts/2010/01/29/is-an-object-empty/</guid>
<description><![CDATA[Как можно узнать, если ли в объекте какие-нибудь свойства.]]></description>
<content:encoded><![CDATA[<p>Сколько способов проверить объект (хеш) на пустоту?</p>

<p>
<pre><code class="javascript">
var hash = {}
JSON.stringify(hash) === '{}'
Object.equals(hash, {}) // for in comparision
Object.keys(hash).length === 0
Object.isEmpty(hash) // for (var k in hash) return false
</code></pre>
</p>

<section>
<h>Потестим…</h>
<pre><code class="javascript">
Object.equals = function (a, b)
{
	for (var k in a)
		if (!(k in b) || a[k] !== b[k])
			return false
	
	for (var k in b)
		if (!(k in a) || a[k] !== b[k])
			return false
	
	return true
}

Object.keys = function (s)
{
	var r = []
	for (var k in s)
		r.push(k)
	return r
}

Object.isEmpty = function (s)
{
	for (var k in s)
		return false
	return true
}

var hash = {},
	count = 10000

console.time('JSON')
for (var i = 0; i < count; i++)
	JSON.stringify(hash) === '{}'
console.timeEnd('JSON')
//=> 61ms

console.time('equals')
for (var i = 0; i < count; i++)
	Object.equals(hash, {})
console.timeEnd('equals')
//=> 49ms

console.time('keys.length')
for (var i = 0; i < count; i++)
	Object.keys(hash).length === 0
console.timeEnd('keys.length')
//=> 44ms

console.time('isEmpty')
for (var i = 0; i < count; i++)
	Object.isEmpty(hash)
console.timeEnd('isEmpty')
//=> 38ms

console.time('isEmpty inlined')
for (var i = 0; i < count; i++)
{
	for (var k in hash)
		false
	true
}
console.timeEnd('isEmpty inlined')
//=> 26ms
</code></pre>

<p>Тестил на самом старом интеловском маке (2 ГГц) в фаерфоксе 3.6.</p>

</section>]]></content:encoded>
</item><item>
<title>Раскрашиваем яваскрипт</title>
<link>http://kung-fu-tzu.ru/posts/2010/01/28/highlight-javascript-kinda-textmate/</link>
<pubDate>Thu, 28 Jan 2010 15:48:34 +0000</pubDate>
<category><![CDATA[клиент]]></category><category><![CDATA[javascript]]></category><category><![CDATA[highlight]]></category>
<guid isPermalink="false">http://kung-fu-tzu.ru/posts/2010/01/28/highlight-javascript-kinda-textmate/</guid>
<description><![CDATA[Почти как текстмейт (местами даже лучше).]]></description>
<content:encoded><![CDATA[<p>Осилил, наконец, полноценную раскраску для яваскрипта. В <a href="http://softwaremaniacs.org/soft/highlight/">хайлайтере</a> уже была <a href="http://softwaremaniacs.org/blog/2007/01/20/highlight-js-javascript/">поддержка яваскрипта</a>, но простенькая. А мне хотелось, чтобы все было так же, как в текстмейте, да еще с такими же точно цветами. И вот, на основе стиля sunburst с парочкой добавлений, и с полностью переделанными правилами раскраски получилась это:</p>

<p><img src="http://kung-fu-tzu.ru/posts/2010/01/28/highlight-javascript-kinda-textmate/i/example.png"/></p>

<p>А вот тестовая страничка с кучей <a href="http://kung-fu-tzu.ru/pages/highlight-js-tm.html">хитрого яваскрипта</a>, откуда и была сфоткана картиночка выше.</p>

<p>Для того, чтобы надежно распарсить регулярки (они <a href="http://kung-fu-tzu.ru/pages/highlight-js-tm.html#regexps">внизу тестовой странички</a>), которые очень похожи на оператор деления и на комментарии («<a href="http://softwaremaniacs.org/blog/2008/11/24/highlightjs-50-beta/">Регэкспы и деления</a>»), пришлось чуть-чуть пропатчить хайлайтер. Надеюсь, Иван скоро примет <a href="http://kung-fu-tzu.ru/posts/2010/01/28/highlight-javascript-kinda-textmate/i/highlight-javascript-like-textmate.patch">патч</a>, или придумает красивый способ объяснить парсеру нужные яваскрипту тонкости.</p>

<p>Если вам тоже хочется такую раскраску, милости прошу: модуль с правилами <a href="http://kung-fu-tzu.ru/posts/2010/01/28/highlight-javascript-kinda-textmate/i/javascript-tm.js">javascript-tm.js</a> и пропатченный <a href="http://kung-fu-tzu.ru/posts/2010/01/28/highlight-javascript-kinda-textmate/i/highlight.js">highlight.js</a>.</p>]]></content:encoded>
</item><item>
<title>RuTils String#translify() и String#dirify() JavaScript port</title>
<link>http://kung-fu-tzu.ru/posts/2009/12/11/rutils-string-translify-and-string-dirify-javascript-port/</link>
<pubDate>Fri, 11 Dec 2009 12:48:23 +0000</pubDate>
<category><![CDATA[клиент]]></category><category><![CDATA[javascript]]></category><category><![CDATA[ruby]]></category><category><![CDATA[string]]></category>
<guid isPermalink="false">http://www.cmsbuilder.ru/blog/?p=517</guid>
<description><![CDATA[Просто портировал транслитерацию.]]></description>
<content:encoded><![CDATA[<p>Да, это именно то, что написано в заголовке.</p>

<p>Сейчас мы используем эту штуковину, чтобы получать адреса коктейлей из их названий так же, как это делает серверная часть на руби. Честно говоря, гонять строки на клиенте мне не очень понравилось, так что мы скоро откажемся от этого кода. Поэтому, выкладываю исходник здесь, а не на гитхабе.</p>

<p><pre>
<code class="javascript">
// ported from rutils.rb
;(function(){

var LOWER =
{
	"і":"i","ґ":"g","ё":"yo","№":"#","є":"e",
	"ї":"yi","а":"a","б":"b",
	"в":"v","г":"g","д":"d","е":"e","ж":"zh",
	"з":"z","и":"i","й":"y","к":"k","л":"l",
	"м":"m","н":"n","о":"o","п":"p","р":"r",
	"с":"s","т":"t","у":"u","ф":"f","х":"h",
	"ц":"ts","ч":"ch","ш":"sh","щ":"sch","ъ":"'",
	"ы":"yi","ь":"","э":"e","ю":"yu","я":"ya"
}

var UPPER =
{
	"Ґ":"G","Ё":"YO","Є":"E","Ї":"YI","І":"I",
	"А":"A","Б":"B","В":"V","Г":"G",
	"Д":"D","Е":"E","Ж":"ZH","З":"Z","И":"I",
	"Й":"Y","К":"K","Л":"L","М":"M","Н":"N",
	"О":"O","П":"P","Р":"R","С":"S","Т":"T",
	"У":"U","Ф":"F","Х":"H","Ц":"TS","Ч":"CH",
	"Ш":"SH","Щ":"SCH","Ъ":"'","Ы":"YI","Ь":"",
	"Э":"E","Ю":"YU","Я":"YA"
}

var undef, myName = 'RuTils', Me = self[myName] = 
{
	// Заменяет кириллицу в строке на латиницу. Немного специфично потому что поддерживает
	// комби-регистр (Щука -> Shuka)
	translify: function (str)
	{
		var res = []
		
		for (var i = 0; i < str.length; i++)
		{
			var c = str.charAt(i), r
			
			if ((r = UPPER[c]) !== undef)
			{
				if (LOWER[str.charAt(i+1)] !== undef)
					r = r.toLowerCase().capitalize()
			}
			else
			{
				r = LOWER[c]
				if (r === undef)
					r = c
			}
			
			res[i] = r
		}
		
		return res.join('')
	},
	
	dirify: function (s)
	{
		return s.translify()
				.replace(/(\s&\s)|(\s&amp;\s)/g, ' and ')
				.replace(/\W/g, ' ')
				.replace(/^_+|_+$/g, '')
				.replace(/^\s+|\s+$/g, '') // trim
				.translify() // yes, second
				.replace(/[\s\-]+/g, '-')
				.toLowerCase()
	}
}

// log("Щука".trans() == 'schuka')
// log("апельсиновый сок".trans() == 'apelsinovyiy-sok')

String.prototype.translify = function ()
{
	return Me.translify(this);
}

String.prototype.trans = function ()
{
	return Me.dirify(this);
}


})();

</code></pre></p>]]></content:encoded>
</item><item>
<title>Управление яваскриптовой памятью в энжинксе</title>
<link>http://kung-fu-tzu.ru/posts/2009/12/03/nginx-spidermonkey-memory-management/</link>
<pubDate>Thu, 03 Dec 2009 05:22:07 +0000</pubDate>
<category><![CDATA[сервер]]></category><category><![CDATA[C]]></category><category><![CDATA[embedding javascript]]></category><category><![CDATA[nginx]]></category><category><![CDATA[ngx_http_javascript_module]]></category><category><![CDATA[ngx_http_js_module]]></category><category><![CDATA[serverside javascript]]></category><category><![CDATA[spidermonkey]]></category>
<guid isPermalink="false">http://www.cmsbuilder.ru/blog/?p=507</guid>
<description><![CDATA[Переплетаем нативные объекты энжи с их представлением в яваскрипте.]]></description>
<content:encoded><![CDATA[<section>
<h>Пишем сценарий</h>

<p><strong>UPD 2010-06-08</strong>: С тех пор модуль оченно уложнился и точек входа в яваскрипт стало гораздо больше. Теперь каждая обертка укоренняется и связывается с нативным запросом сразу же после оборачивания.</p>

<p>Когда только задумался, а не встроить ли яваскрипт в энжинкс, все казалось легко. Достаточно обернуть нативный энжинксовский запрос в объект и передать в яваскриптовый движок. А что там с ним дальше будет — не моя забота, ведь, в яваскрипте есть автоматическая сборка мусора. Оказалось все не так уж и просто. Есть как минимум три разных сценария обработки запроса, каждый из которых требует вдумчивого анализа.</p>

<p>Первый, и самый простой, тип. Пришел запрос, обернули его в яваскриптовый объект, передали назначенному в конфиге обработчику (обычная яваскриптовая функция, то есть замыкание) и получили ответ. Собственно все. Дальше нам не нужна ни структура запроса в памяти энжинкса, ни объект-обертка в памяти cпайдерманки. Надо только передать текст ответа дальше энжинксу и можно идти спать.</p>

<p>Второй сценарий посложнее. Начало такое же как и у первого. Запрос → обертка → обработчик. Дальше в развитие событий врывается самая клевая штука во всем этом яваскриптовом встраивании — сохранение запроса в глобальном объекте, чтобы его не съел уборщик. После того, как яваскрипт вернет нам управление, мы уже не сможем просто забыть об объекте-оберке. Это потому, что энжинкс и слыхом не слыхивал о сборке мусора в яваскрипте: он просто освободит память из пула запроса и отдаст ее другому запросу, а то и хуже — под данные чьих-нибудь буферов :) Следовательно, почти сразу после сохранения, объект-обертка начинает указывать в пустоту. А это значит что энжинкс упадет тоже сразу (или хуже того — не сразу) после того, как <nobr>кто-то</nobr> в яваскрипте попробует обратиться к сохраненному запросу. Например, <nobr>кто-то</nobr> решит собрать статистику по запросам и станет складывать их в какой-нибудь массив, чтобы потом за один раз посчитать к каким локациям обращались чаще всего. <nobr>Тут-то</nobr> все и рухнет, так как ни одного их этих запросов уже нет, а память совсем не похожа на то, что там было в момент сохранения объекта-обертки в массиве. Да, вот так закручено, люблю этот мир ;)</p>

<p>Третий тип запросов еще хитрее, если такое вообще возможно. Начало опять простое: запрос к энжинксу → обертка → вызов яваскрипта. И тут в развитие событий врывается вторая суперудобная и обалденная штука из мира динамических языков — замыкания. <nobr>Кто-то</nobr> в яваскрипте решает выполнить подзапрос или поставить таймер. При таких делах яваскрипт сохранит объект-обертку так же, как и во втором ходе событий, и нам придется решать все те же проблемы. Но само замыкание для нас никто не сохранит, а это значит, что когда подзапрос выполнится или таймер сработает, уже не будет ни объекта-обертки, ни замыкания — их всех удалит сборщик мусора — останутся просто указатели в пустоту. То есть этот тип развития событий подразумевает взаимные ссылки: яваскрипта на энжинкс, а энжинкса на яваскрипт.</p>
</section>


<section>
<h>О скорости</h>

<p>Третий тип развития событий самый полный и включает в себя решение всех задач по встраиванию скриптового движка в материнское приложение. Если так, то тогда зачем мы тут себе голову забиваем этими примитивными путями. А вот зачем.</p>

<p>Энжинкс славится своей скоростью и малым потреблением ресурсов. Ну, собственно одно из другого следует. И раз он так хорош, то не стоит его совсем уж портить этим медленный SpiderMonkey (в сравнении с Google v8 и SquirrelFish Extreme — да, ключевики всё же должны встречаться в теле страницы). Так вот, если все делать по третьему варианту, то для каждого, даже, малюсенького запросика мы должны проделать кучу работы по управлению памятью. И если научиться определять, по какому пути пошел процесс, то можно изрядно сэкономить. Один момент. Второй вариант — это когда яваскрипт <nobr>куда-то</nobr> складывает запросы — совершенно неопределим для спайдерманки (или v8) без запуска полного цикла сборки мусора. А это просто сказочно медленно. Таким образом, мы избавляемся от одной из веток развития событий. Итак, их осталось две: простая, когда можно забить на мусоросборщик почти совсем; и сложная, когда надо везде все запомнить и всячески перестраховаться.</p>

<p>Запросов первого типа будет подавляющее большинство. Это могут быть запросы к кешу, к статусу какого-нибудь процесса, или запросы типа «запланируй вот это, а я пока погуляю». Поэтому, стоит научиться определять их быстро. В энжинксе, начиная с версии 0.8 (не помню точно с какой подверсии) появился счетчик ссылок на запрос. Да, как в перле — <a href="http://en.wikipedia.org/wiki/Reference_counting">reference counting</a>. ИМХО, просто, понятно и относительно надежно. Нам, скриптерам (а я далеко не один такой — чего только в энжинкс не страивают), этот счетчик вообще незаменим, и не только для решения этой задачи. Так вот, его-то мы и используем для разделения задачи на две, обозначенные выше. Если <code>r->main->count</code> больше единицы, то у нас ситуация, когда запрос будет жить дольше, чем выполняется наш обработчик. Если же равен единице, то можно на все забить и все выкинуть (ну, почти). Если меньше единицы, значит мы <nobr>где-то</nobr> накосячили, и стоит ждать сегфолта. Научившись быстро определять, какие задачи надо решить в конкретном случае, пора уже начать решать эти задачи.</p>
</section>

<section>
<h>Решаем проблемы</h>

<p>В первом варианте задач никаких и нет. Вновь созданный объект-обертка сразу же передается функции внутри яваскрипта в виде параметра (или инвоканта), что защищает его от уничтожения, пока эта эта функция не завершится. А завершится она как раз тогда, когда этот объект становится нам больше не нужен. Надо только не забыть выставить указатель на нативный запрос в ноль. Здесь могут быть мелкие неприятности, типа того, что спайдерманки решит начать уборку как раз между созданием объекта и передачей его в функцию. Это возможно в многопоточных приложениях и для борьбы с такими неприятностями есть функции входа и выхода в «неубираемую» область (<code><a href="https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JS_EnterLocalRootScope">JS_EnterLocalRootScope()</a></code> и <code><a href="https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JS_LeaveLocalRootScope"> JS_LeaveLocalRootScope()</a></code>). А еще, из неприятностей, могут взять и отменить защиту от сборки для параметров, переданных извне. Но это все мелочи и они решаются легко и быстро.</p>

<p>И вот, <nobr>наконец-то,</nobr> решение задач второго варианта (он же третий по первоначальному табелю). Повторим коротко условия:
<ol>
	<li>Нельзя ссылаться на отработавший свое запрос энжинкса.</li>
	<li>Нельзя дать уборщику уничтожить объект-обертку, который еще может понадобиться энжи.</li>
	<li>Необходимо сохранить от уборщика все яваскриптовые функции, которые еще понадобятся.</li>
	<li>Надо не забыть разрешить уничтожение объекта-обертки, когда он больше не нужен.</li>
</ol></p>

<p>Итак по порядку.</p>
</section>

<section>
<h>1. Инвалидация указателя</h>

<p>Избавиться от ссылки на запрос энжинкса (это такая большущая многоярусная структура) <nobr>вообще-то</nobr> нельзя. То есть пока обертка плавает <nobr>где-то</nobr> в памяти яваскрипта, она будет ссылаться <nobr>куда-то</nobr>. То есть, через час после запроса мы все-таки можем вызвать <code>r.sendHeaders(200, "Content-type: plain: encoding=utf-8")</code>. Важно <nobr>как-то</nobr> понять, что этого делать нельзя и сообщить об этом скрипту. Тут все очень просто: достаточно сказать объекту-обертке, что теперь он указывает на <code>NULL</code>, а при каждом обращении к свойствам или методам проверять, не равен ли <code>NULL</code>, случайно, наш обернутый запрос. В том случае, если уже нал (нулл, нил, нуль, ноль, зеро), то выбросить исключение и вернуть пользователю красивую ошибку 500. Это, прямо скажем, очень здорово, если сравнивать с падением всего рабочего процесса, обслуживающего в этот момент тысячу—другую невинных клиентов.</p>

<p>Как же выставить указатель на оборачиваемый объект в <code>NULL</code>? Спасибо Игорю, это очень просто. Достаточно подписаться на событие уничтожения запроса, и в обработчике этого события выставить указатель в ноль. Просто, быстро и надежно, как сам нжинкс.</p>
</section>

<section>
<h>2. Защита от уничтожения — корни</h>

<p>Защитить объект от уборки (на рабочем столе и по дому, a еще разрешить ему посуду не мыть) можно как угодно легко. Можно присвоить его глобальной переменной или свойству другого защищенного объекта (<code>global. requests. push(r)</code>). Можно записать его в слот защищенного объекта (<code><a href="https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JS_GetReservedSlot">JS_SetReservedSlot()</a></code>), а можно сделать его самого защищенным, назначив корнем (<code><a href="https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JS_AddRoot">JS_AddRoot()</a></code>). Сборщик мусора начинает помечать нужные еще объекты с таких корней. Глобальный объект, например, является именно таким корнем. В данном случае, мы создадим в структуре запроса энжинкса специальный указатель (<code>jsval</code>), который попросим назначать корнем всякий объект, на который он указывает. И, да, именно, запишем туда над объект-обертку. Все, его не уничтожат до тех пор, пока мы не уничтожим корень. А корень мы уничтожим там же, где выставляли <code>NULL</code> — в обработчике события уничтожения запроса. Но об этом далее.</p>
</section>

<section>
<h>3. Защита от уничтожения — слоты в корнях</h>

<p>Защитить функции (они же замыкания, или, почти, как <a href="http://alenacpp.blogspot.com/2007/04/blog-post.html">функторы</a>) можно теми же методами, что и сам объект-обертку. Собственно, год назад я так и поступил: добавлял для обработчика тела новый корень, а потом его удалял. Теперь же добавились таймеры и подзапросы. Клепать корни для всех этих товарищей в глобальном пространстве не хочется, так как запросов будут тысячи. Нам хватит нагрузки от создания корней для самих этих тысяч запросов. К тому же создание корня (как сейчас <a href="http://mxr.mozilla.org/mozilla-central/source/js/src/jsgc.cpp#1163">видно из исходников</a> спайдерманки) — это добавление ключа в хеш по значению указателя. И чем больше мы туда запихнем, тем хуже для нас. Кстати, как раз для того, чтобы разгрузить этот хеш мы тут и затеяли все эти выкрутасы с разделение запросов на два типа, из чего теперь получился целый здоровенный пост (вы читать не устали?).</p>

<p>Так вот, вместо корней лучше используем слоты. Они тоже не быстрые (судя по исходникам спайдерманки там нет ничего быстрого), но это хотя бы не поиск в таблице из тысяч записей. А еще слоты хороши тем, что их можно потом не стирать. То есть объект-обертка когда-нибудь будет убран а вместе с ним и все эти функции со своими локальными и замкнутыми переменными. Для v8 это вообще подарок с его поколениями переменных. Этот подход позволяет обработчику запроса энжинкса отцепить объект-обертку и одним махом избавиться ото всех его паразитов.</p>
</section>

<section>
<h>4. Освобождение памяти</h>

<p>Правильно отцепить объект-обертку — дело не хитрое. Отцепим его там же, где помечали его пустым, в обработчике уничтожения запроса. Ах, как же я был рад, когда нашел его в исходниках энжинкса! Тут достаточно вызвать <code><a href="https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JS_RemoveRoot">JS_RemoveRoot()</a></code> и все в порядке.</p>

<p>После подробного разбора всех накладных расходов по управлению памятью, становится понятно, зачем мы тут всю эту кашу заварили.</p>
</section>

<section>
<h>Послесловие</h>

<p>При чем тут v8? А при том, что завязываться на один браузер, тьфу, то есть движок яваскрипта, мы, клиентские программисты, не приучены. Сегодня (точнее уже вчера) хорош и стабилен спайдерманки, а завтра (точнее уже сегодня) становится хорош v8. А потом станет хорош еще <nobr>кто-то,</nobr> или даже совсем не яваскрипт. А ведь корни, слоты и указатели на нативные объекты есть везде, где убирают мусор автоматом.</p>

<p>Где исходники? Они — <a href="http://github.com/kung-fu-tzu/ngx_http_js_module">на гитхабе</a>. Скоро поставлю красивые гитхабовские ссылочки на строчечки (обожаю гитхаб!).</p>

<p><em>Ого, а хотел в пару абзацев уложиться.</em></p>
</section>]]></content:encoded>
</item><item>
<title>Немного о работе</title>
<link>http://kung-fu-tzu.ru/posts/2009/11/14/about-work/</link>
<pubDate>Sat, 14 Nov 2009 10:11:38 +0000</pubDate>
<category><![CDATA[клиент]]></category>
<guid isPermalink="false">http://www.cmsbuilder.ru/blog/?p=502</guid>
<description><![CDATA[Иншейкер ищет новых друзей.]]></description>
<content:encoded><![CDATA[<p>Наш любимый <a href="http://www.inshaker.ru/">коктейльный сайт</a> — и, в частности, я сам — нуждается в ежедневной хорошо оплачиваемой поддержке людей, программирующих на яваскрипте. Мы, даже, сделали <a href="http://www.inshaker.ru/job.html">секретную страничку</a> специально для них. Она маленькая и очень оптимистичная ;)</p>]]></content:encoded>
</item><item>
<title>Статистика от Google Analytics для amCharts через XSLT</title>
<link>http://kung-fu-tzu.ru/posts/2009/10/26/charts-from-google-analytics-to-amcharts-by-xslt/</link>
<pubDate>Mon, 26 Oct 2009 16:21:45 +0000</pubDate>
<category><![CDATA[сервер]]></category><category><![CDATA[analytics]]></category><category><![CDATA[charts]]></category><category><![CDATA[google]]></category><category><![CDATA[inshaker]]></category><category><![CDATA[xslt]]></category>
<guid isPermalink="false">http://www.cmsbuilder.ru/blog/?p=490</guid>
<description><![CDATA[Простой скрипт на баше и парочка XSL-шаблонов.]]></description>
<content:encoded><![CDATA[<p>Сделал новую <a href="http://www.inshaker.ru/about.html">статистику посещаемости</a> для <a href="http://www.inshaker.ru/">Иншейкера</a>. Рисуется она, как и <a href="http://vaskas.ru/2008/08/08/displaying-google-analytics-charts-on-the-website/">прежняя</a>, с помощью <a href="http://www.amcharts.com/">amCharts</a>. Но теперь все действия по выкачиванию и преобразовыванию данных выполняются простым bash-скриптом и стандартной утилитой <a href="http://xmlsoft.org/XSLT/xsltproc2.html">xsltproc</a>. Думаю, <code>bash</code> и <code>xsltproc</code> есть у всех.</p>

<p>Дело делают всего два скрипта: <code>login.sh</code> и <code>update.sh</code>. Первый логинится в гугл, используя мыло и пароль из переменных окружения (нечего им в коде делать). Гугл в ответ отдает авторизационный токен, который, согласно документации, можно использовать около двух недель. Второй скрипт выкачивает статистику в формате <a href="http://en.wikipedia.org/wiki/Atom_(standard)">Atom</a>, расширенном гуглом. На этом программирование на баше заканчивается, и начинается XSLT.</p>

<p>Скрипты со стилями положил на гитхаб в <a href="http://github.com/kung-fu-tzu/analytics-xslt">analytics-xslt</a>.</p>

<p><strong>UPD</strong>: разошелся и сделал нам <a href="http://www.inshaker.ru/geeks/stats.html">статистику по браузерам</a>.</p>]]></content:encoded>
</item><item>
<title>GitX</title>
<link>http://kung-fu-tzu.ru/posts/2009/10/10/gitx/</link>
<pubDate>Sat, 10 Oct 2009 15:13:08 +0000</pubDate>
<category><![CDATA[сервер]]></category><category><![CDATA[git]]></category><category><![CDATA[gitx]]></category><category><![CDATA[mac]]></category>
<guid isPermalink="false">http://www.cmsbuilder.ru/blog/?p=484</guid>
<description><![CDATA[Хвалю GitX]]></description>
<content:encoded><![CDATA[<p><img src="http://kung-fu-tzu.ru/posts/2009/10/10/gitx/i/gitx.png" alt="GitX" class="aside"/>Выбросил дорогущий <a href="http://kung-fu-tzu.ru/posts/2008/11/24/versions-app-released/">Versions.app</a> вслед за эсвээном. Теперь обожаю бесплатный <a href="http://gitx.frim.nl/">GitX</a>. Thanks a lot Pieter!</p>]]></content:encoded>
</item><item>
<title>Array#sort()</title>
<link>http://kung-fu-tzu.ru/posts/2009/09/02/array-sort/</link>
<pubDate>Wed, 02 Sep 2009 02:41:02 +0000</pubDate>
<category><![CDATA[клиент]]></category><category><![CDATA[performance]]></category><category><![CDATA[sort]]></category>
<guid isPermalink="false">http://www.cmsbuilder.ru/blog/?p=468</guid>
<description><![CDATA[Три удивительных способа сортировки в яваскрипте.]]></description>
<content:encoded><![CDATA[<section>
<p>Так как во время сортировки массива (а также обращения) яваскрипт не создает его копию, сортировать числа можно очень быстро. И это здорово — но скучно.</p>

<p>Интереснее становится, когда надо отсортировать большой массив объектов по нескольким вложенным правилам. Например, отсортировать <a href="http://www.inshaker.ru/cocktails.html">кучу коктейлей</a> по количеству в них водки, далее отсортировать по количеству ингредиентов, а затем еще и по алфавиту. Вопрос в том, как выразить такую логику.</p>
</section>

<section>
<h>Многообразие</h>
<p>Предположим, что нам нужно отсортировать массив объектов <code>{x: число, y: число, z: число}</code> сначала по <code>x</code>, потом по <code>y</code> потом по <code>z</code>. Есть как минимум три очевидных способа.</p>

<dl>
<dt>Каскадный:</dt>
<dd>
<pre><code class="javascript">
array.sort(byZ).sort(byY).sort(byX)
</code></pre>
<small>Так можно делать, когда интерпретатор поддерживает «stable sort» и сортировки не связаны (тут так и есть).</small>
</dd>
</dl>

<dl>
<dt>Одиночный:</dt>
<dd>
<pre><code class="javascript">
array.sort(function (a, b) { return byX(a, b) || byY(a, b) || byZ(a, b) })
</code></pre>
<small><strong>UPD 2010-01-12</strong>: Конструкция хитрая, но работает. В яваскрипте (и еще, как минимум, в перле, руби, питоне и Си) оператор <code>||</code> не приводит аргументы к булеву типу, что позволяет клеить такие цепочки хоть до посинения.</small>
</dd>
</dl>

<dl>
<dt>Раскрытый (он же «inlined»):</dt>
<dd>
<pre><code class="javascript">
array.sort(function (a, b) { return a.x - b.x || a.y - b.y || a.z - b.z })
</code></pre>
</dd>
</dl>

<p>В хороших и зрелых браузерах они все работают быстро и сортируют одинаково правильно (ага!). Но в нехороших браузерах, что-то подтормаживает, а что-то даже и не сортирует.</p>
</section>

<section>
<h>Кросбраузерность и скорость</h>
<p>Каскадный способ очень красив и даже не очень тупит, но не работает в Опере (включая зарелизенную десятку) и в Хроме (включая альфы четверки, <a href="http://code.google.com/p/v8/issues/detail?id=90">они об этом знают</a>). В третьем фаерфоксе, во всех ИЕ, а также в сафари три типа сортировки дают правильный порядок элементов. То есть придется париться с обертками.</p>

<p>Тесты показывают, что одиночный <code>sort()</code> почти в два раза быстрее каскадного. Раскрытый — еще быстрее раза в полтора-два-три (даже в хроме с его мегаумным В8). Забавно, что каскадный и одиночный способы сортировки дают одинаковые результаты в ИЕ 6 и 7 (в восьмом картина такая же как и в других браузерах).</p>
</section>

<section>
<h>Тестим</h>
<p><pre><code class="javascript">var messed =
[
	{x: 2, y: 0, z: 0},
	{x: 2, y: 0, z: 1},
	{x: 2, y: 0, z: 2},
	{x: 2, y: 1, z: 0},
	{x: 2, y: 1, z: 1},
	{x: 2, y: 1, z: 2},
	{x: 2, y: 2, z: 0},
	{x: 2, y: 2, z: 1},
	{x: 2, y: 2, z: 2},
	
	{x: 0, y: 0, z: 0},
	{x: 0, y: 0, z: 1},
	{x: 0, y: 0, z: 2},
	{x: 0, y: 1, z: 0},
	{x: 0, y: 1, z: 1},
	{x: 0, y: 1, z: 2},
	{x: 0, y: 2, z: 0},
	{x: 0, y: 2, z: 1},
	{x: 0, y: 2, z: 2},
	
	{x: 1, y: 0, z: 0},
	{x: 1, y: 0, z: 1},
	{x: 1, y: 0, z: 2},
	{x: 1, y: 1, z: 0},
	{x: 1, y: 1, z: 1},
	{x: 1, y: 1, z: 2},
	{x: 1, y: 2, z: 0},
	{x: 1, y: 2, z: 1},
	{x: 1, y: 2, z: 2}
]

var sorted =
[
	{x: 0, y: 0, z: 0},
	{x: 0, y: 0, z: 1},
	{x: 0, y: 0, z: 2},
	{x: 0, y: 1, z: 0},
	{x: 0, y: 1, z: 1},
	{x: 0, y: 1, z: 2},
	{x: 0, y: 2, z: 0},
	{x: 0, y: 2, z: 1},
	{x: 0, y: 2, z: 2},
	
	{x: 1, y: 0, z: 0},
	{x: 1, y: 0, z: 1},
	{x: 1, y: 0, z: 2},
	{x: 1, y: 1, z: 0},
	{x: 1, y: 1, z: 1},
	{x: 1, y: 1, z: 2},
	{x: 1, y: 2, z: 0},
	{x: 1, y: 2, z: 1},
	{x: 1, y: 2, z: 2},
	
	{x: 2, y: 0, z: 0},
	{x: 2, y: 0, z: 1},
	{x: 2, y: 0, z: 2},
	{x: 2, y: 1, z: 0},
	{x: 2, y: 1, z: 1},
	{x: 2, y: 1, z: 2},
	{x: 2, y: 2, z: 0},
	{x: 2, y: 2, z: 1},
	{x: 2, y: 2, z: 2}
]

function byX (a, b) { return a.x - b.x }
function byY (a, b) { return a.y - b.y }
function byZ (a, b) { return a.z - b.z }
function single (a, b) { return byX(a, b) || byY(a, b) || byZ(a, b) }
function combined (a, b) { return a.x - b.x || a.y - b.y || a.z - b.z }

var m = messed.slice()
console.time('multiple')
for (var i = 0; i < 1000; i++)
{
	m.sort(byZ),
	m.sort(byY),
	m.sort(byX)
}
console.timeEnd('multiple')

var s = messed.slice()
console.time('single')
for (var i = 0; i < 1000; i++)
{
	s.sort(single)
}
console.timeEnd('single')

var c = messed.slice()
console.time('combined')
for (var i = 0; i < 1000; i++)
{
	c.sort(combined)
}
console.timeEnd('combined')
</code></pre></p>
</section>]]></content:encoded>
</item><item>
<title>Кастомные события</title>
<link>http://kung-fu-tzu.ru/posts/2009/07/27/custom-events/</link>
<pubDate>Mon, 27 Jul 2009 02:28:32 +0000</pubDate>
<category><![CDATA[клиент]]></category><category><![CDATA[events]]></category><category><![CDATA[fixes]]></category><category><![CDATA[IE]]></category>
<guid isPermalink="false">http://www.cmsbuilder.ru/blog/?p=465</guid>
<description><![CDATA[Первые впечатления от произвольных событий во всех браузерах.]]></description>
<content:encoded><![CDATA[<p>Во всех браузерах, кроме сами знаете какого, можно играться с событийным движком браузера, как душе угодно. Гибкость дается наравне с нативными событиями: можно называть их как угодно, настраивать всплываемость и отменяемость, добавлять свои свойства и методы. Такие трюки удобны для создания виджетов со своей моделью событий; и для имитации полезных событий браузера там, где их не поддерживают (типа, <code>onready</code> или <code>onhashchanged</code>); а еще для расширения базовой логики приложения кем-то третьим (например, события <code>hide</code>/<code>show</code> для отключения анимации в скрытых нодах); да мало ли для чего еще могли бы пригодиться свои собственные события. Но не в IE.</p>

<p>Событийную модель можно реализовать на яваскрипте, и воспользоваться всеми этими прелестями. Но только не для нод в дереве документа, а для простых обектов (тут ничего нового — очередная реализация интерфейса EventTarget). А ведь хочется вешать обработчики именно на ноды, документ, окно… на аяксовый запрос, наконец!</p>

<p>Решили научить IE распространять по документу выдуманные типы событий и посмотреть, что из этого выйдет. У этой задачи есть простое решение: достатачно на яваскрипте повторить движок браузера для подписки/отписки и распространения событий. Код получается интересный, так что это решение вполне приемлемо. С другой стороны, зачем дублировать то, что уже реализовали нативно, а значит быстро. Надо всего-то чуть-чуть допилить браузер.</p>

<p>В этом случае можно выбрать некоторое событие как транспорт. Это событие должно по умолчанию всплывать и не иметь никаких встроенных обработчиков. Поискав немного, нашел <code>oneditfocus</code>. Мы его нигде не используем, а по параметрам он подходит как раз. На нем, пока, и остановился — самое сложное позади. Далее дело техники: научить <code>addEventListener</code> и <code>dispathEvent</code> понимать, какие события обрабатывать как есть, а какие оборачивать в <code>oneditfocus</code>. Здесь тоже ничего сложного: ищем событие в списке нативных и, если не нашли — оборачиваем.</p>

<p>В итоге, за наши труды получаем такой код, без проблем работающий в IE 6-7-8:
<pre><code class="javascript">
window.addEventListener("ready", function (e) { alert("got an event type " + e.type) }, false)
var ready = document.createEvent("Event")
ready.initEvent("ready", true, true)
window.dispathEvent(ready)
//=> got event type ready
</code></pre></p>

<p>Конечно, IE не поддерживает ни <code>addEventListener</code>, ни <code>dispathEvent</code>, но их поддержку нетрудно добавить.</p>

<p><strong>UPD</strong>: <a href="http://dean.edwards.name/">Дин Эдвардс</a> сделал работающую модель событий для IE в своей библиотеке <a href="http://code.google.com/p/base2/">Base2</a>. Она показалась мне громоздкой и сумбурной. Да и стиль кодирования Дина меня тоже не особо прет: все эти точки с запятой, бее ;)</p>]]></content:encoded>
</item>

</channel>
</rss>