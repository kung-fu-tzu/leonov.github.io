---
title: "Такие разные removeClassName'ы"
description: "О том, как сильно можно усложнить даже самую примитивную вещь."
categories: [клиент, DOM, javascript, lib]
layout: post
time: 04:22:18
lang: ru
---
<p>
Казалось бы, что может быть проще, чем написать функцию по удалению имени класса из свойства ноды. Наверное из-за того, что задачка легкая, ее решают все. Только все ее решают по-разному.
</p>

<p>
Вот как у <a href="http://github.com/sstephenson/prototype/blob/34ee2078f8c61272b69bc9166fd0bf7f94dde5fc/src/dom.js#L336">прототайпа 1.6</a>:
<pre><code class="javascript">
removeClassName: function(element, className) {
  if (!(element = $(element))) return;
  element.className = element.className.replace(
    new RegExp("(^|\\s+)" + className + "(\\s+|$)"), ' ').strip();
  return element;
},
</code></pre>
Тут мы видим два дополнительных вызова внешних функций: <code>$(element)</code> и <code>.strip()</code>. А еще строка собирается для каждого обращения. И еще регексп компилится каждый раз и при выполнении запоминает и заполняет <code>$1</code> и <code>$2</code>. А зачем?
</p>

<p>
А вот так у джейквери:
<pre><code class="javascript">
remove: function( elem, classNames ) {
	if (elem.nodeType == 1)
		elem.className = classNames !== undefined ?
			jQuery.grep(elem.className.split(/\s+/), function(className){
				return !jQuery.className.has( classNames, className );
			}).join(" ") :
			"";
},
</code></pre>
Этот код пожестче. Здесь и <code>split</code> с <code>join</code>'ом, и поиск <code>className</code> в <code>jQuery</code>, а в <code>className</code>'е потом поиск <code>has</code>. Ну, а про вызов замыкания на каждый имеющийся класс вообще умолчим. Задача укорачивания строки решена максимально помпезно.
</p>

<p>
В обеих библиотеках эти функции оборачиваются во что-то еще. Так, в коде джейквери прямым текстом написано «internal only, use removeClass("class")». Такой подход действительно полезен, когда к библиотеке пишут плагины и расширения. Хуков можно надобавлять, потрейсить, попрофайлить или еще что-нибудь побочное прикрепить.
</p>

<p>
На наших сайтах добавление и удаление классов происходит очень часто, а иногда очень-очень часто для целой кучи элементов (где именно? — как зарелизим — покажу; <strong>UPD 03.01.2009</strong>: <a href="http://moscow.retailstars.ru/">показываю</a>). Когда пишешь такой код, не хочется думать о том, что вызов <code>removeClassName()</code> может быть дорогим. Хочется простой и быстрый метод. Например, такой:
<pre><code class="javascript">
var rexCache = {}, R = RegExp
Element.prototype.removeClassName = function (cn)
{
	return this.className = this.className.replace
	(
		rexCache[cn] ||
		(rexCache[cn] = new R('(?:^| +)(?:' + cn + '(?:$| +))+', 'g')), ' '
	)
	.replace(/^\s+|\s+$/g, '')
}
</code></pre>
Тут мы убрали все, что смогли, и ничего лишнего не добавили. Даже кеш, и тот закеширован в локальной переменной. Ах да: вы только, пожалуйста, не используйте эту функцию, не протестировав ее хорошенько на своих проектах. То, что она работает у нас, еще ничего не значит. Мы же не Резиг, и не мощная тусовка рельсовиков. Мы просто <a href="http://www.inshaker.ru/">Иншейкер</a> (а как же без ссылки на мой любимый коктейльный сайт).
</p>

<p>
Понимаю, в новых браузерах и вызовы методов быстрые, и встроенное кеширование регэкспов есть, и строки там молниеносные, и вообще у них уже джит на дворе. Так что париться о таких вещах как-то неудобно. Но меня не покидает чувство, что усложнять не нужно.
</p>

<p>
Вот так не по-доброму получилось. И это при том, что я фанат всего что делает Резиг, и обожаю рельсы целиком, вместе с прототайпом.
</p>