---
title: "XHTML шепчу…"
description: "Парсим HTML внутри XHTML-странички."
categories: [клиент, javascript, xhtml]
layout: post
time: 09:08:16
lang: ru
---
<p>Сегодня утром вернулся к выводу RSS-ленты <a href="http://www.programica.ru/">на сайте Програмики</a>. И обнаружил, что <code>innerHTML</code> меня не спасает. Что же делать? Решение есть, но сначала хорошенько опишу проблему.</p>

<h3>XHTML</h3>
<p>С недавних пор мы решили верстать сайты в XHTML. Затея не нова, скажете вы, — сейчас каждый уважающий себя верстальщик все делает по стандартам и о валидности не забывает. Однако, как мы можем узнать из статьи Ивана Сагалаева «<a href="http://softwaremaniacs.org/blog/2005/12/19/xhtml-you-say/">XHTML, говорите?</a>», не все так просто, и многие разработчики не подозревают, что верстают вовсе не в режиме XHTML, а в старом добром HTML–режиме. Дело в HTTP-заголовке Content-type, и вся свистопляска начинается только тогда, когда вы вместо привычного <code>text/html</code> дадите браузеру нюхнуть <code>application/xhtml+xml</code>. Или <code>text/xml</code> на худой конец. Браузер сразу обнаружит, что вы, наконец, одумались и выбрали самый современный отформатированный формат документов и сопутствующие ему самые стандартные стандарты. Однако&nbsp; прежней свою страницу вы не увидите. Делов-то, сейчас слеши в конце &lt;br&gt; и &lt;img&gt; поставим, и все. А не все. Когда вы начнете программировать, предварительно исправив разметку, указав пространство имен и разобравшись с кодировкой, вас настигнут бонусные неприятности с передовым форматом. Самое время вернуться к теме поста.</p>

<p>Классическим примером разницы в движках HTML и XHTML было отсутствие&nbsp; у XHTML-элементов свойства <code>innerHTML</code>. То есть загрузить что-то аморфное аяксом и вывести в div стало нельзя. Свойство присваивается, JavaScript ведь этого не запрещает, но реакции никакой нет. Народ стал мучаться с интерфейсами <code>DOMParser</code> и <code>DOMSerializer</code>, чтобы эмулировать любимое свойство. И, честно говоря, некоторый успех был. Позже браузеры научились и сами имитировать <code>innerHTML</code> в режиме XHTML (вероятнее всего тем же способом) и сейчас можно не опасаясь писать нечто вроде <code>$('content').innerHTML = '&lt;h1&gt;Сильно &lt;i&gt;лень&lt;/i&gt; городить createElement() и appendChild()&lt;/h1&gt;'</code>. Хотя свойство и называется <code>innerHTML</code> на самом деле HTML ему скормить нельзя. Это скорее <code>innerXHTML</code>. То есть такое дело не пройдет: <code>mailDiv.innerHTML = '&lt;p&gt;забудем закрыть "p", поставим неразрывный&amp;nbsp;пробел, а еще картинку вставим &lt;img alt="постринке"&gt;'</code>. И что произойдет? В обычном режиме браузер напряжет свои HTML-извилины и догадается о том, что вы имели ввиду. В новом мире XML умен должен быть не браузер, а мы. А сам браузер, как ему и положено, откажется парсить такую гадость и выбросит исключение.</p>

<p><dl>
	<dt>Вот какие исключения бывают:</dt>
	<dd>Firefox 2: An invalid or illegal string was specified</dd>
	<dd>Firefox 3: Component returned failure code: 0x80004003 (NS_ERROR_INVALID_POINTER) [nsIDOMNSHTMLElement.innerHTML]</dd>
	<dd>Safari 3: NO_MODIFICATION_ALLOWED_ERR: DOM Exception 7</dd>
</dl></p>

<p>Opera 9 умеет парсить HTML сама. За что нижайший ей поклон.</p>

<h3>Великий браузер</h3>
<p>Первое решение, которое пришло мне на ум, это поправить разметку простенькими регулярками.</p>

<pre><code class="javascript">
rex = /&lt;(img|br|hr|link|input)(.+?)\/?&gt;/g
markup = markup.replace(rex, '&lt;$1$2/&gt;').replace(/(&amp;nbsp;)/g, '&nbsp;')
</code></pre>

<p>После этого чать кода заработала. Потом из любопытства поглядел на список сущностей в HTML. А потом попался фрагмент кода с перемешанными тегами. Писать парсер перехотелось. Помучавшись в раздумьях, решил попробовать распарсить HTML на сервере, а потом выдать его как HTML. Идея мне понравилась, по натуре&nbsp; я серверный программист и раньше воспринимал браузер только как дисплей. Потом, правда, одумался.</p>

<p>Одуматься удалось и на этот раз. Зачем, спрашиввается, мне парсить HTML на сервере, если у меня в руках самый совершенный парсер HTML — собственно браузер. Не найдя рационального ответа на этот вопрос, решил парсить кривой HTML на клиенте. Вот только куда тиранический XML-режим сослал этот самый парсер — не понятно.</p>

<p>Отступлю немного и отвечу на вопрос, ответ на который вас, возможно, интересует. Почему у меня HTML весь такой кривой и неправильный. Ответ прост как шланг — на нашем блоге мы решили парсить сырую RSS-выдачу. А получаем мы очень вольно составленный HTML.</p>

<p>Так вот. Где же cпрятан парсер HTML, когда у нас все кругом в XHTML? Сегодня получить парсер в лисе, скриптом невозможно. Про вебкит и оперу по запросу "new HTMLDocument()" тоже ничего найти не удалось (искал, правда, спустя рукава — любимчик-то мой уже облажался). <code>XMLParser</code>, как видно из названия, парсит только XML (правда это может быть и XUL, и MathML, и SVG и…). Создать новый HTML-документ с помощью <code>document.implementation.createDocument(…)</code> можно, но будет он XHTML. Конструкция <code>(new DOMParser()).parseFromString("...", "text/html")</code> не сработает, так как <code>DOMParser</code> не поддерживает <code>text/html</code>. Прямо так и пишет: not implemented.</p>

<p>Промучавшись полдня с «крутыми» технологиями, решил попробовать самую простую — спрятать iframe и в него загрузить html-файл. Как мы и рассчитываем <code>window.onload</code> срабатывает когда все загрузится, в том числе и фрейм. Добавлять фрейм можно&nbsp; динамически, но тогда <code>onload</code> может произойти раньше, чем iframe будет готов. Так как я успел и не забыл, браузеры меня вознаградили. Наградой явился объект <code>document</code>, который умеет парсить HTML. Ура!</p>

<p>Как это выгладит в коде? Как всегда было в HTML:
<pre><code class="javascript">
var html = $('htmliframe').contentDocument.firstChild
html.innerHTML = '&lt;div&gt;' + markup + '&lt;/div&gt;'
</code></pre>
Родные, милые черты...</p>

<p>Осталось извлечь полученное дерево и доставить его на место назначения.
<pre><code class="javascript">
// почистим ноду назначения
while (destination.firstChild)
  destination.removeChild(destination.firstChild)
// склонируем HTML-дерево (в нашем случае див с детьми)
clone = html.firstChild.cloneNode(true)
// вставим див куда надо
content.appendChild(clone)
</code></pre>
</p>

<p>В будущих версиях браузеров, возможно, надо будет адаптировать ноды <code>clone = document.adoptNode(clone)</code>, но пока они на adoptNode ругаются.</p>

<h3>Итог</h3>
<p>HTML парсится и выводится в Firefox 2, 3 и Safari 3. Opera 9 все умеет сама. IE и Safari 2 не умеют XHTML совсем, но все же умеют клиентский XSL через xml-stylesheet. Получается, мостик между HTML и XML переброшен.
</p>