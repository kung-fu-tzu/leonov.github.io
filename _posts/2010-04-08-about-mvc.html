---
title: "Еще чуть-чуть о MVC"
description: "Про то, как мы готовим MVC."
categories: [клиент, javascript, mvc, inshaker]
layout: post
time: 14:55:45
---
<p><strong>UPD 2010-11-28</strong>: Статейка получилась такая, какая получилась ;) Из текста можно понять, что автор еще не полностью въехал в суть проблемы. Скоро напишу хорошую, годную статью по следам новейших исследований британских ученых.</p>

<p>Модель, она данными занимается. Контроллер нужен чтобы связывать модель и представление, это чтобы модель могла ничего не знать про представление. Ну, а представление просто все рисует по данным из модели. Казалось бы, куда уж проще? Да, просто, но как только начинаешь делать что-то реальное возникает куча вопросов.</p>

<section>
<h>Куча вопросов</h>

<p>Разделять код? Зачем?</p>
<p>Зачем нужен этот «цикл МВЦ»?</p>
<p>С чего все начинается?</p>
<p>Что значит одно «вызывает» другое?</p>
<p>Можно ли как-то нарушать правила движения?</p>
<p>А как же производительность?</p>
</section>


<section>
<h>Разделяй и властвуй</h>

<p>Зачем делить? Судя по опыту, только для упрощения программирования. Не себе, конечно, а тому парню, который потом будет разбираться в вашем коде. Тут собственно все вокруг этого и строится. MVC это ж ведь паттерн. Правда, такая схема будет работать только в том случае, если «тот парень» тоже сдвинут на этом паттерне и знает, какой стороной его держать.</p>

<p>Судя по своим ощущениям, это реально упрощает программирование мне, когда выдается возможность что-то поковырять в новом для меня коде. Если мне известно, что там «правильный» MVC — что бы это ни значило для меня — то работа всегда пойдет быстро. Мне известно, что ноды генерятся во вьюхе. Там же на них вешаются всякие онклики. Сразу пропускаю контроллер, так как он всегда все передает в модель, меняя только название метода. Дальше, в модели мне тоже все понятно: тут, типа, данные в чистом виде, безо всякого мусора. Тут я как раз ковыряю какую-нить логику сортировки чего-нить и передаю данные дальше. Удобно.</p>

<p>Разделение вообще полезно, особенно в больших проектах. Круто, когда разработчик модели должен всего-то договориться о нескольких методах с разработчиком представления, теперь он может полностью отдаться оптимизации аяксовых запросов, кешированию и другим потрясающим вещам. Второй чувак, который паяет вьюху, может, в свою очередь, забыть про сервер вообще и думать только о том, как наиболее эффективно сгенерить стопицот нод с картинками, как организовать отложенную загрузку чего-нибудь и, наконец, исправить ту разъехавшуюся страничку в шестом ИЕ.</p>

<p>Попытаюсь проиллюстрировать примером:</p>
<pre><code class="javascript">
// вывод щенков вне зависимости от того, откуда их привезли
Widget.View.prototype.renderTheCutePuppiesNames = function (puppies)
{
	// вьюха уже хорошо знает, куда надо нарисовать щенков
	// а именно в какой-то ранее созданный элемент ul или ol
	var puppiesRootNode = this.puppiesRootNode
	
	for (var i = 0; i < puppies.length; i++)
	{
		// создаем для щенка элемент списка
		var li = document.createElement('li')
		// говорим стилям, что это именно симпатичный щенок
		li.className = 'cute-puppy'
		// добавляем щенку текст с именем в лучших традициях DOM API
		li.appendChild(document.createTextNode(puppies[i].name))
		// добавляем вновь созданный елемент с имем щенка в список
		puppiesRootNode.appendChild(li)
	}
}

// просто добавляем щенка в массив и не думаем о том, где их будут показывать
Widget.Model.prototype.addACutePuppy = function (puppy)
{
	// добавдяем симпатичного щенка в модель
	this.data.push(puppy)
	
	// оповещаем вьюху о том, что щенков поприбавилось
	this.view.modelChanged(this.data)
}

// не запариваясь передадим модели нового щенка
Widget.Controller.prototype.newCutePuppyAdded = function (puppyName)
{
	// не просто передадим, а обернем в объект, чтобы модели было удобнее,
	// контроллер же как раз для этого и нужен ;)
	this.model.addACutePuppy({name: puppyName})
}
</code></pre>
</section>


<section>
<h>В цикле</h>

<p>Под циклом все понимают последовательность передачи управления: View -> Controller -> Model -> View. Это все видели на картинках про MVC. А зачем он нужен? И почему именно в такой последовательности?</p>

<p>Здесь дело опять же в предсказуемости действий. Кликнули мышкой и знаем, что это событие обработает представление: выяснит, над какой нодой мы кликнули мышкой, связан ли с этой нодой объект, если да, то пора передать его, и только его в контроллер. Контроллер быстренько превращает осмысленное действие «кликнут коктейльный ингредиент такой-то» в робоподобное «переключить цвет шерсти щенка такого-то в зеленый». Когда дело доходит до модели, мы уже точно знаем, что надо делать, все лишние детали возникшего события остались на предыдущих этапах обработки, а значит, можно просто применить новые данные к модели и, если она изменилась, оповестить об этом представление.</p>

<p>Еще один бонус в том, что заранее известны все точки входа в код. Это всегда методы вьюхи, которые реагируют на события, пришедшие от пользователя. Возможность перечислить точки входа очень полезна при изучении кода, который написан давно и/или кем-то другим.</p>

<p>Маленький пример:</p>
<pre><code class="javascript">
// мы можем подписаться на все интересующие виджет события прямо тут,
// ах, как же потом будет удобно все это сопровождать :)
Widget.View.prototype.bindEvents = function (nodes)
{
	// для замыкания
	var input = nodes.input,
		me = this
	// подписываемся на клик и все, остальное — дело контролёра ;)
	nodes.button.addEventListener('click', function (e) { me.controller.newCutePuppyAdded(input.value) }, false)
}
</code></pre>
</section>


<section>
<h>Первый круг</h>

<p>Когда виджет только-только создан, он еще пустой. Движок MVC сначала надо прогреть. Прогреваем мы вот как. В представлении запоминаем ноды, которые надо будет наполнить новыми элементами, подписываемся на события, инициализируем сторонние виджеты. В модели сохраняем объекты-обертки для базы данных, предвычисляем всякие индексы, что-нибудь кешируем. После прогрева MVC полностью готов к бою. Пора взлетать, то есть запускать тот самый первый круг цикла. Обычно, представление как-то вычисляет, что конкретно надо рисовать по данным, переданным на этапе прогрева. Надо только передать контроллеру эти данные. Сейчас буду показывать пример, чтобы все стало ясно.</p>

<pre><code class="javascript">
Widget.prototype.bind = function (nodes, dataSources)
{
	// тут просим представление запомнить свои корневые ноды,
	// подписаться на события мыши или клавы,
	// насоздавать других вложенных виджетов и так далее
	this.view.setNodes(nodes)
	
	// тут просим модель запомнить источники данных,
	// с которыми ей предстоит работать
	this.model.setSources(dataSources)
}

Widget.prototype.setPuppies = function (puppies)
{
	// просим контроллер передать модели те данные,
	// которые станут ее первоначальным состоянием
	this.controller.setInitialPuppies(puppies)
}

// создаем пустой виджет, он еще не прогрет
var widget = new Widget()

// прогреваем виджет
widget.bind(nodes, dataSources)

// взлетаем
widget.setPuppies(['Тузик', 'Бобик', 'Шарик', 'Мухтар'])

// теперь виджет готов адекватно реагировать на внешние события
widget.getPuppy('Мурзик')
//=> Exception: "Мурзик" is an incorrect name for a puppy
</code></pre>
</section>


<section>
<h>Это вызов</h>

<p>У кого как, а у нас передача сообщений между частями MVC, это простые вызовы методов. То есть мы не создавали вокруг MVC никаких дополнительных построек, типа <a href="https://developer.mozilla.org/en/DOM/EventTarget">EventTarget</a> или <a href="http://en.wikipedia.org/wiki/Observer_pattern">Observer</a>. То есть виджет у нас всегда состоит из одной модели, одного представления и одного контроллера. Между ними все и вертится. Если нужно, например, два представления, то это легко организовать с помощью чего-то типа паттернов, перечисленных выше. Надо искренне стараться не усложнять простое и упрощать сложное ;)</p>

<p>Один важный момент, это асинхронность. Если модель должна обратиться за данными на сервер, то тут возникает вопрос: как же быть с простыми вызовами методов? Все просто. Модель должна сама с этим справиться, внутри себя. То есть, получив сообщение от контроллера, модель лезет на сервер, что-то там запрашивает, ждет, получает все необходимые данные и только затем дергает представление с новыми данными. Просто вызывает метод, как если бы не было всей этой возни с сервером. Пока модель выполняет все эти действия, вьюха отдыхает как ни в чем не бывало.</p>

<p>Забавно то, что методы, которые вызываются для передачи сообщения не могут вернуть никакого значения. Ну, то есть могут, но это лишено смысла, так как результат вызова придет с другой стороны: как раз по этому самому кругу MVC. Эта хитрость избавляет от необходимости синхронного выполнения всех задач в любой части MVC. Непривычно, но скоро становится очень удобно.</p>

<p>Небольшая иллюстрация важного асинхронного момента:</p>
<pre><code class="javascript">
// добавляем щенка, предарительно проверив допустимость его клички
Widget.Model.prototype.addAStrangePuppy = function (puppy)
{
	function checked (e)
	{
		if (e.result == 'error')
			// если имя в базе не найдено — громко ругаемся
			throw new Error('"' + puppyName + '" is an incorrect name for a puppy')
		else
		{
			// спокойно добавляем нового щенка,
			// эта функция в свою очередь дернет вьюху с новым набором щенков
			this.addACutePuppy(puppy)
		}
	}
	
	// спрашиваем сервер, правильное ли имя у нового щенка?
	// вторым параметром передадим колбек: представим, что обертка базы работает именно так ;)
	this.dataSources.puppyDataBase.checkPuppyName(puppy.name, checked)
}
</code></pre>
</section>


<section>
<h>Против шерсти</h>

<p>В принципе, никто не мешает представлению лезть в модель за данными самостоятельно. Контроллер может иногда забить на модель и вызвать представление самостоятельно. Модель тоже может потянуться к представлению за какой-то информацией о состоянии. И так далее. Если у вас такое происходит, то об этом надо предупреждать, так как этого от вас никто не ждет ;) В нарушении правил движения есть пара особенно неприятных моментов.</p>

<p>Первый момент. Действительно встречаются такие события в представлении, которые никак не влияют на модель. Но если они не влияют на модель, зачем тогда они нужны? Ведь весь смысл представления в этом самом представлении модели. То есть всегда полезно думать о представлении и контроллере как о помощниках модели. Они помогают отобразить то, что у модели на душе. То есть весь интерфейс с выведенными данными должен быть воспроизводим только по данным модели. Это значит, что можно взять состояние модели, сдампить его в JSON, перезагрузить страничку, скормить модели этот JSON и получить точь-в-точь такой же виджет, каким он был до перезагрузки.</p>

<p>Второй момент, это асинхронность. Как мы помним, модель может захотеть сходить в сеть за новой порцией данных. Потом она может их как-то обработать, закешировать или отбросить. Если мы полезем напрямую в модель из представления, никто нам не гарантирует, что мы не напоремся на пустые, еще не пришедшие данные, или не ввергнем страничку в бесконечный цикл запросов к серверу. Для борьбы с такими неприятностями можно вовсю пользоваться приватными методами. Это как раз тот способ, которым можно просто запретить движение в неудобном модели направлении.</p>

<p>Знаю только один случай когда вся эта изолированно-асинхронная модель рушится. Это тогда, когда кто-то нажал на кнопку отправки формы и надо либо блокировать отправку, либо разрешить. А данные, необходимые для принятия решения, лежат в модели. Вызвать модель мы можем, но получим от нее результат неизвестно когда. В таком случае, можно либо сразу заблокировать отправку формы, отправить сообщение в модель про то, что надо бы отправить эту форму. Модель там покумекает, и, возможно, разрешит-таки форму отправить. При таком раскладе, представление может принудительно отправить форму методом <code>form.submit()</code>. А что делать, если это не форма, а, например, событие драгэндропа, пришедшее от операционки через браузер. Операционка не будет ждать выполнения нашего аякса. В таких ситуациях MVC уже мешает и его придется нарушать.</p>
</section>


<section>
<h>Производительность</h>

<p></p>

</section>

