---
title: "Управление яваскриптовой памятью в энжинксе"
description: "Переплетаем нативные объекты энжи с их представлением в яваскрипте."
categories: [сервер, C, embedding javascript, nginx, ngx_http_javascript_module, ngx_http_js_module, serverside javascript, spidermonkey]
layout: post
time: 05:22:07
---
<section>
<h>Пишем сценарий</h>

<p><strong>UPD 2010-06-08</strong>: С тех пор модуль оченно уложнился и точек входа в яваскрипт стало гораздо больше. Теперь каждая обертка укоренняется и связывается с нативным запросом сразу же после оборачивания.</p>

<p>Когда только задумался, а не встроить ли яваскрипт в энжинкс, все казалось легко. Достаточно обернуть нативный энжинксовский запрос в объект и передать в яваскриптовый движок. А что там с ним дальше будет — не моя забота, ведь, в яваскрипте есть автоматическая сборка мусора. Оказалось все не так уж и просто. Есть как минимум три разных сценария обработки запроса, каждый из которых требует вдумчивого анализа.</p>

<p>Первый, и самый простой, тип. Пришел запрос, обернули его в яваскриптовый объект, передали назначенному в конфиге обработчику (обычная яваскриптовая функция, то есть замыкание) и получили ответ. Собственно все. Дальше нам не нужна ни структура запроса в памяти энжинкса, ни объект-обертка в памяти cпайдерманки. Надо только передать текст ответа дальше энжинксу и можно идти спать.</p>

<p>Второй сценарий посложнее. Начало такое же как и у первого. Запрос → обертка → обработчик. Дальше в развитие событий врывается самая клевая штука во всем этом яваскриптовом встраивании — сохранение запроса в глобальном объекте, чтобы его не съел уборщик. После того, как яваскрипт вернет нам управление, мы уже не сможем просто забыть об объекте-оберке. Это потому, что энжинкс и слыхом не слыхивал о сборке мусора в яваскрипте: он просто освободит память из пула запроса и отдаст ее другому запросу, а то и хуже — под данные чьих-нибудь буферов :) Следовательно, почти сразу после сохранения, объект-обертка начинает указывать в пустоту. А это значит что энжинкс упадет тоже сразу (или хуже того — не сразу) после того, как <nobr>кто-то</nobr> в яваскрипте попробует обратиться к сохраненному запросу. Например, <nobr>кто-то</nobr> решит собрать статистику по запросам и станет складывать их в какой-нибудь массив, чтобы потом за один раз посчитать к каким локациям обращались чаще всего. <nobr>Тут-то</nobr> все и рухнет, так как ни одного их этих запросов уже нет, а память совсем не похожа на то, что там было в момент сохранения объекта-обертки в массиве. Да, вот так закручено, люблю этот мир ;)</p>

<p>Третий тип запросов еще хитрее, если такое вообще возможно. Начало опять простое: запрос к энжинксу → обертка → вызов яваскрипта. И тут в развитие событий врывается вторая суперудобная и обалденная штука из мира динамических языков — замыкания. <nobr>Кто-то</nobr> в яваскрипте решает выполнить подзапрос или поставить таймер. При таких делах яваскрипт сохранит объект-обертку так же, как и во втором ходе событий, и нам придется решать все те же проблемы. Но само замыкание для нас никто не сохранит, а это значит, что когда подзапрос выполнится или таймер сработает, уже не будет ни объекта-обертки, ни замыкания — их всех удалит сборщик мусора — останутся просто указатели в пустоту. То есть этот тип развития событий подразумевает взаимные ссылки: яваскрипта на энжинкс, а энжинкса на яваскрипт.</p>
</section>


<section>
<h>О скорости</h>

<p>Третий тип развития событий самый полный и включает в себя решение всех задач по встраиванию скриптового движка в материнское приложение. Если так, то тогда зачем мы тут себе голову забиваем этими примитивными путями. А вот зачем.</p>

<p>Энжинкс славится своей скоростью и малым потреблением ресурсов. Ну, собственно одно из другого следует. И раз он так хорош, то не стоит его совсем уж портить этим медленный SpiderMonkey (в сравнении с Google v8 и SquirrelFish Extreme — да, ключевики всё же должны встречаться в теле страницы). Так вот, если все делать по третьему варианту, то для каждого, даже, малюсенького запросика мы должны проделать кучу работы по управлению памятью. И если научиться определять, по какому пути пошел процесс, то можно изрядно сэкономить. Один момент. Второй вариант — это когда яваскрипт <nobr>куда-то</nobr> складывает запросы — совершенно неопределим для спайдерманки (или v8) без запуска полного цикла сборки мусора. А это просто сказочно медленно. Таким образом, мы избавляемся от одной из веток развития событий. Итак, их осталось две: простая, когда можно забить на мусоросборщик почти совсем; и сложная, когда надо везде все запомнить и всячески перестраховаться.</p>

<p>Запросов первого типа будет подавляющее большинство. Это могут быть запросы к кешу, к статусу какого-нибудь процесса, или запросы типа «запланируй вот это, а я пока погуляю». Поэтому, стоит научиться определять их быстро. В энжинксе, начиная с версии 0.8 (не помню точно с какой подверсии) появился счетчик ссылок на запрос. Да, как в перле — <a href="http://en.wikipedia.org/wiki/Reference_counting">reference counting</a>. ИМХО, просто, понятно и относительно надежно. Нам, скриптерам (а я далеко не один такой — чего только в энжинкс не страивают), этот счетчик вообще незаменим, и не только для решения этой задачи. Так вот, его-то мы и используем для разделения задачи на две, обозначенные выше. Если <code>r->main->count</code> больше единицы, то у нас ситуация, когда запрос будет жить дольше, чем выполняется наш обработчик. Если же равен единице, то можно на все забить и все выкинуть (ну, почти). Если меньше единицы, значит мы <nobr>где-то</nobr> накосячили, и стоит ждать сегфолта. Научившись быстро определять, какие задачи надо решить в конкретном случае, пора уже начать решать эти задачи.</p>
</section>

<section>
<h>Решаем проблемы</h>

<p>В первом варианте задач никаких и нет. Вновь созданный объект-обертка сразу же передается функции внутри яваскрипта в виде параметра (или инвоканта), что защищает его от уничтожения, пока эта эта функция не завершится. А завершится она как раз тогда, когда этот объект становится нам больше не нужен. Надо только не забыть выставить указатель на нативный запрос в ноль. Здесь могут быть мелкие неприятности, типа того, что спайдерманки решит начать уборку как раз между созданием объекта и передачей его в функцию. Это возможно в многопоточных приложениях и для борьбы с такими неприятностями есть функции входа и выхода в «неубираемую» область (<code><a href="https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JS_EnterLocalRootScope">JS_EnterLocalRootScope()</a></code> и <code><a href="https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JS_LeaveLocalRootScope"> JS_LeaveLocalRootScope()</a></code>). А еще, из неприятностей, могут взять и отменить защиту от сборки для параметров, переданных извне. Но это все мелочи и они решаются легко и быстро.</p>

<p>И вот, <nobr>наконец-то,</nobr> решение задач второго варианта (он же третий по первоначальному табелю). Повторим коротко условия:
<ol>
	<li>Нельзя ссылаться на отработавший свое запрос энжинкса.</li>
	<li>Нельзя дать уборщику уничтожить объект-обертку, который еще может понадобиться энжи.</li>
	<li>Необходимо сохранить от уборщика все яваскриптовые функции, которые еще понадобятся.</li>
	<li>Надо не забыть разрешить уничтожение объекта-обертки, когда он больше не нужен.</li>
</ol></p>

<p>Итак по порядку.</p>
</section>

<section>
<h>1. Инвалидация указателя</h>

<p>Избавиться от ссылки на запрос энжинкса (это такая большущая многоярусная структура) <nobr>вообще-то</nobr> нельзя. То есть пока обертка плавает <nobr>где-то</nobr> в памяти яваскрипта, она будет ссылаться <nobr>куда-то</nobr>. То есть, через час после запроса мы все-таки можем вызвать <code>r.sendHeaders(200, "Content-type: plain: encoding=utf-8")</code>. Важно <nobr>как-то</nobr> понять, что этого делать нельзя и сообщить об этом скрипту. Тут все очень просто: достаточно сказать объекту-обертке, что теперь он указывает на <code>NULL</code>, а при каждом обращении к свойствам или методам проверять, не равен ли <code>NULL</code>, случайно, наш обернутый запрос. В том случае, если уже нал (нулл, нил, нуль, ноль, зеро), то выбросить исключение и вернуть пользователю красивую ошибку 500. Это, прямо скажем, очень здорово, если сравнивать с падением всего рабочего процесса, обслуживающего в этот момент тысячу—другую невинных клиентов.</p>

<p>Как же выставить указатель на оборачиваемый объект в <code>NULL</code>? Спасибо Игорю, это очень просто. Достаточно подписаться на событие уничтожения запроса, и в обработчике этого события выставить указатель в ноль. Просто, быстро и надежно, как сам нжинкс.</p>
</section>

<section>
<h>2. Защита от уничтожения — корни</h>

<p>Защитить объект от уборки (на рабочем столе и по дому, a еще разрешить ему посуду не мыть) можно как угодно легко. Можно присвоить его глобальной переменной или свойству другого защищенного объекта (<code>global. requests. push(r)</code>). Можно записать его в слот защищенного объекта (<code><a href="https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JS_GetReservedSlot">JS_SetReservedSlot()</a></code>), а можно сделать его самого защищенным, назначив корнем (<code><a href="https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JS_AddRoot">JS_AddRoot()</a></code>). Сборщик мусора начинает помечать нужные еще объекты с таких корней. Глобальный объект, например, является именно таким корнем. В данном случае, мы создадим в структуре запроса энжинкса специальный указатель (<code>jsval</code>), который попросим назначать корнем всякий объект, на который он указывает. И, да, именно, запишем туда над объект-обертку. Все, его не уничтожат до тех пор, пока мы не уничтожим корень. А корень мы уничтожим там же, где выставляли <code>NULL</code> — в обработчике события уничтожения запроса. Но об этом далее.</p>
</section>

<section>
<h>3. Защита от уничтожения — слоты в корнях</h>

<p>Защитить функции (они же замыкания, или, почти, как <a href="http://alenacpp.blogspot.com/2007/04/blog-post.html">функторы</a>) можно теми же методами, что и сам объект-обертку. Собственно, год назад я так и поступил: добавлял для обработчика тела новый корень, а потом его удалял. Теперь же добавились таймеры и подзапросы. Клепать корни для всех этих товарищей в глобальном пространстве не хочется, так как запросов будут тысячи. Нам хватит нагрузки от создания корней для самих этих тысяч запросов. К тому же создание корня (как сейчас <a href="http://mxr.mozilla.org/mozilla-central/source/js/src/jsgc.cpp#1163">видно из исходников</a> спайдерманки) — это добавление ключа в хеш по значению указателя. И чем больше мы туда запихнем, тем хуже для нас. Кстати, как раз для того, чтобы разгрузить этот хеш мы тут и затеяли все эти выкрутасы с разделение запросов на два типа, из чего теперь получился целый здоровенный пост (вы читать не устали?).</p>

<p>Так вот, вместо корней лучше используем слоты. Они тоже не быстрые (судя по исходникам спайдерманки там нет ничего быстрого), но это хотя бы не поиск в таблице из тысяч записей. А еще слоты хороши тем, что их можно потом не стирать. То есть объект-обертка когда-нибудь будет убран а вместе с ним и все эти функции со своими локальными и замкнутыми переменными. Для v8 это вообще подарок с его поколениями переменных. Этот подход позволяет обработчику запроса энжинкса отцепить объект-обертку и одним махом избавиться ото всех его паразитов.</p>
</section>

<section>
<h>4. Освобождение памяти</h>

<p>Правильно отцепить объект-обертку — дело не хитрое. Отцепим его там же, где помечали его пустым, в обработчике уничтожения запроса. Ах, как же я был рад, когда нашел его в исходниках энжинкса! Тут достаточно вызвать <code><a href="https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JS_RemoveRoot">JS_RemoveRoot()</a></code> и все в порядке.</p>

<p>После подробного разбора всех накладных расходов по управлению памятью, становится понятно, зачем мы тут всю эту кашу заварили.</p>
</section>

<section>
<h>Послесловие</h>

<p>При чем тут v8? А при том, что завязываться на один браузер, тьфу, то есть движок яваскрипта, мы, клиентские программисты, не приучены. Сегодня (точнее уже вчера) хорош и стабилен спайдерманки, а завтра (точнее уже сегодня) становится хорош v8. А потом станет хорош еще <nobr>кто-то,</nobr> или даже совсем не яваскрипт. А ведь корни, слоты и указатели на нативные объекты есть везде, где убирают мусор автоматом.</p>

<p>Где исходники? Они — <a href="http://github.com/kung-fu-tzu/ngx_http_js_module">на гитхабе</a>. Скоро поставлю красивые гитхабовские ссылочки на строчечки (обожаю гитхаб!).</p>

<p><em>Ого, а хотел в пару абзацев уложиться.</em></p>
</section>